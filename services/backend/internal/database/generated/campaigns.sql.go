// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: campaigns.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addCampaignMember = `-- name: AddCampaignMember :one
INSERT INTO campaign_members (
    campaign_id,
    user_id,
    role,
    alias
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, campaign_id, user_id, role, joined_at, alias
`

type AddCampaignMemberParams struct {
	CampaignID pgtype.UUID `json:"campaign_id"`
	UserID     pgtype.UUID `json:"user_id"`
	Role       MemberRole  `json:"role"`
	Alias      pgtype.Text `json:"alias"`
}

func (q *Queries) AddCampaignMember(ctx context.Context, arg AddCampaignMemberParams) (CampaignMember, error) {
	row := q.db.QueryRow(ctx, addCampaignMember,
		arg.CampaignID,
		arg.UserID,
		arg.Role,
		arg.Alias,
	)
	var i CampaignMember
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.UserID,
		&i.Role,
		&i.JoinedAt,
		&i.Alias,
	)
	return i, err
}

const checkGmInactivity = `-- name: CheckGmInactivity :one
SELECT
    id,
    last_gm_activity_at,
    EXTRACT(EPOCH FROM (NOW() - last_gm_activity_at)) / 86400 AS days_inactive
FROM campaigns
WHERE id = $1
`

type CheckGmInactivityRow struct {
	ID               pgtype.UUID        `json:"id"`
	LastGmActivityAt pgtype.Timestamptz `json:"last_gm_activity_at"`
	DaysInactive     int32              `json:"days_inactive"`
}

func (q *Queries) CheckGmInactivity(ctx context.Context, id pgtype.UUID) (CheckGmInactivityRow, error) {
	row := q.db.QueryRow(ctx, checkGmInactivity, id)
	var i CheckGmInactivityRow
	err := row.Scan(&i.ID, &i.LastGmActivityAt, &i.DaysInactive)
	return i, err
}

const clearCampaignTimeGate = `-- name: ClearCampaignTimeGate :exec
UPDATE campaigns
SET
    current_phase_expires_at = NULL,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) ClearCampaignTimeGate(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, clearCampaignTimeGate, id)
	return err
}

const countActiveLocksInCampaign = `-- name: CountActiveLocksInCampaign :one
SELECT COUNT(*)
FROM compose_locks cl
INNER JOIN scenes s ON cl.scene_id = s.id
WHERE s.campaign_id = $1
  AND cl.expires_at > NOW()
`

func (q *Queries) CountActiveLocksInCampaign(ctx context.Context, campaignID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveLocksInCampaign, campaignID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPendingRollsInCampaign = `-- name: CountPendingRollsInCampaign :one
SELECT COUNT(*)
FROM rolls r
INNER JOIN scenes s ON r.scene_id = s.id
WHERE s.campaign_id = $1
  AND r.status = 'pending'
`

func (q *Queries) CountPendingRollsInCampaign(ctx context.Context, campaignID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPendingRollsInCampaign, campaignID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserOwnedCampaigns = `-- name: CountUserOwnedCampaigns :one
SELECT COUNT(*) FROM campaigns WHERE owner_id = $1
`

func (q *Queries) CountUserOwnedCampaigns(ctx context.Context, ownerID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserOwnedCampaigns, ownerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCampaign = `-- name: CreateCampaign :one
INSERT INTO campaigns (
    title,
    description,
    owner_id,
    settings,
    last_gm_activity_at
) VALUES (
    $1, $2, $3, $4, NOW()
)
RETURNING id, title, description, owner_id, settings, current_phase, current_phase_started_at, current_phase_expires_at, is_paused, last_gm_activity_at, storage_used_bytes, scene_count, created_at, updated_at
`

type CreateCampaignParams struct {
	Title       string      `json:"title"`
	Description pgtype.Text `json:"description"`
	OwnerID     pgtype.UUID `json:"owner_id"`
	Settings    []byte      `json:"settings"`
}

func (q *Queries) CreateCampaign(ctx context.Context, arg CreateCampaignParams) (Campaign, error) {
	row := q.db.QueryRow(ctx, createCampaign,
		arg.Title,
		arg.Description,
		arg.OwnerID,
		arg.Settings,
	)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.OwnerID,
		&i.Settings,
		&i.CurrentPhase,
		&i.CurrentPhaseStartedAt,
		&i.CurrentPhaseExpiresAt,
		&i.IsPaused,
		&i.LastGmActivityAt,
		&i.StorageUsedBytes,
		&i.SceneCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decrementCampaignStorage = `-- name: DecrementCampaignStorage :one
UPDATE campaigns
SET
    storage_used_bytes = GREATEST(0, storage_used_bytes - $2),
    updated_at = NOW()
WHERE id = $1
RETURNING storage_used_bytes
`

type DecrementCampaignStorageParams struct {
	ID               pgtype.UUID `json:"id"`
	StorageUsedBytes int64       `json:"storage_used_bytes"`
}

func (q *Queries) DecrementCampaignStorage(ctx context.Context, arg DecrementCampaignStorageParams) (int64, error) {
	row := q.db.QueryRow(ctx, decrementCampaignStorage, arg.ID, arg.StorageUsedBytes)
	var storage_used_bytes int64
	err := row.Scan(&storage_used_bytes)
	return storage_used_bytes, err
}

const deleteCampaign = `-- name: DeleteCampaign :exec
DELETE FROM campaigns WHERE id = $1
`

func (q *Queries) DeleteCampaign(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteCampaign, id)
	return err
}

const getCampaign = `-- name: GetCampaign :one
SELECT id, title, description, owner_id, settings, current_phase, current_phase_started_at, current_phase_expires_at, is_paused, last_gm_activity_at, storage_used_bytes, scene_count, created_at, updated_at FROM campaigns WHERE id = $1
`

func (q *Queries) GetCampaign(ctx context.Context, id pgtype.UUID) (Campaign, error) {
	row := q.db.QueryRow(ctx, getCampaign, id)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.OwnerID,
		&i.Settings,
		&i.CurrentPhase,
		&i.CurrentPhaseStartedAt,
		&i.CurrentPhaseExpiresAt,
		&i.IsPaused,
		&i.LastGmActivityAt,
		&i.StorageUsedBytes,
		&i.SceneCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCampaignMember = `-- name: GetCampaignMember :one
SELECT id, campaign_id, user_id, role, joined_at, alias FROM campaign_members
WHERE campaign_id = $1 AND user_id = $2
`

type GetCampaignMemberParams struct {
	CampaignID pgtype.UUID `json:"campaign_id"`
	UserID     pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetCampaignMember(ctx context.Context, arg GetCampaignMemberParams) (CampaignMember, error) {
	row := q.db.QueryRow(ctx, getCampaignMember, arg.CampaignID, arg.UserID)
	var i CampaignMember
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.UserID,
		&i.Role,
		&i.JoinedAt,
		&i.Alias,
	)
	return i, err
}

const getCampaignMemberCount = `-- name: GetCampaignMemberCount :one
SELECT COUNT(*) FROM campaign_members
WHERE campaign_id = $1
`

func (q *Queries) GetCampaignMemberCount(ctx context.Context, campaignID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getCampaignMemberCount, campaignID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCampaignMembers = `-- name: GetCampaignMembers :many
SELECT
    cm.id,
    cm.campaign_id,
    cm.user_id,
    cm.role,
    cm.alias,
    cm.joined_at
FROM campaign_members cm
WHERE cm.campaign_id = $1
ORDER BY cm.role DESC, cm.joined_at ASC
`

type GetCampaignMembersRow struct {
	ID         pgtype.UUID        `json:"id"`
	CampaignID pgtype.UUID        `json:"campaign_id"`
	UserID     pgtype.UUID        `json:"user_id"`
	Role       MemberRole         `json:"role"`
	Alias      pgtype.Text        `json:"alias"`
	JoinedAt   pgtype.Timestamptz `json:"joined_at"`
}

func (q *Queries) GetCampaignMembers(ctx context.Context, campaignID pgtype.UUID) ([]GetCampaignMembersRow, error) {
	rows, err := q.db.Query(ctx, getCampaignMembers, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCampaignMembersRow
	for rows.Next() {
		var i GetCampaignMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.UserID,
			&i.Role,
			&i.Alias,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCampaignPhaseStatus = `-- name: GetCampaignPhaseStatus :one

SELECT
    id,
    current_phase,
    current_phase_started_at,
    current_phase_expires_at,
    is_paused,
    settings->>'timeGatePreset' AS time_gate_preset
FROM campaigns WHERE id = $1
`

type GetCampaignPhaseStatusRow struct {
	ID                    pgtype.UUID        `json:"id"`
	CurrentPhase          CampaignPhase      `json:"current_phase"`
	CurrentPhaseStartedAt pgtype.Timestamptz `json:"current_phase_started_at"`
	CurrentPhaseExpiresAt pgtype.Timestamptz `json:"current_phase_expires_at"`
	IsPaused              bool               `json:"is_paused"`
	TimeGatePreset        interface{}        `json:"time_gate_preset"`
}

// ============================================
// PHASE MANAGEMENT QUERIES
// ============================================
func (q *Queries) GetCampaignPhaseStatus(ctx context.Context, id pgtype.UUID) (GetCampaignPhaseStatusRow, error) {
	row := q.db.QueryRow(ctx, getCampaignPhaseStatus, id)
	var i GetCampaignPhaseStatusRow
	err := row.Scan(
		&i.ID,
		&i.CurrentPhase,
		&i.CurrentPhaseStartedAt,
		&i.CurrentPhaseExpiresAt,
		&i.IsPaused,
		&i.TimeGatePreset,
	)
	return i, err
}

const getCampaignStorage = `-- name: GetCampaignStorage :one
SELECT storage_used_bytes FROM campaigns WHERE id = $1
`

func (q *Queries) GetCampaignStorage(ctx context.Context, id pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getCampaignStorage, id)
	var storage_used_bytes int64
	err := row.Scan(&storage_used_bytes)
	return storage_used_bytes, err
}

const getCampaignWithMembership = `-- name: GetCampaignWithMembership :one
SELECT
    c.id, c.title, c.description, c.owner_id, c.settings, c.current_phase, c.current_phase_started_at, c.current_phase_expires_at, c.is_paused, c.last_gm_activity_at, c.storage_used_bytes, c.scene_count, c.created_at, c.updated_at,
    cm.role as user_role
FROM campaigns c
LEFT JOIN campaign_members cm ON c.id = cm.campaign_id AND cm.user_id = $2
WHERE c.id = $1
`

type GetCampaignWithMembershipParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

type GetCampaignWithMembershipRow struct {
	ID                    pgtype.UUID        `json:"id"`
	Title                 string             `json:"title"`
	Description           pgtype.Text        `json:"description"`
	OwnerID               pgtype.UUID        `json:"owner_id"`
	Settings              []byte             `json:"settings"`
	CurrentPhase          CampaignPhase      `json:"current_phase"`
	CurrentPhaseStartedAt pgtype.Timestamptz `json:"current_phase_started_at"`
	CurrentPhaseExpiresAt pgtype.Timestamptz `json:"current_phase_expires_at"`
	IsPaused              bool               `json:"is_paused"`
	LastGmActivityAt      pgtype.Timestamptz `json:"last_gm_activity_at"`
	StorageUsedBytes      int64              `json:"storage_used_bytes"`
	SceneCount            int32              `json:"scene_count"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	UserRole              NullMemberRole     `json:"user_role"`
}

func (q *Queries) GetCampaignWithMembership(ctx context.Context, arg GetCampaignWithMembershipParams) (GetCampaignWithMembershipRow, error) {
	row := q.db.QueryRow(ctx, getCampaignWithMembership, arg.ID, arg.UserID)
	var i GetCampaignWithMembershipRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.OwnerID,
		&i.Settings,
		&i.CurrentPhase,
		&i.CurrentPhaseStartedAt,
		&i.CurrentPhaseExpiresAt,
		&i.IsPaused,
		&i.LastGmActivityAt,
		&i.StorageUsedBytes,
		&i.SceneCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserRole,
	)
	return i, err
}

const getCampaignsWithActiveTimeGates = `-- name: GetCampaignsWithActiveTimeGates :many
SELECT id, title, description, owner_id, settings, current_phase, current_phase_started_at, current_phase_expires_at, is_paused, last_gm_activity_at, storage_used_bytes, scene_count, created_at, updated_at FROM campaigns
WHERE current_phase = 'pc_phase'
  AND current_phase_expires_at IS NOT NULL
  AND current_phase_expires_at > NOW()
  AND is_paused = false
`

func (q *Queries) GetCampaignsWithActiveTimeGates(ctx context.Context) ([]Campaign, error) {
	rows, err := q.db.Query(ctx, getCampaignsWithActiveTimeGates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Campaign
	for rows.Next() {
		var i Campaign
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.OwnerID,
			&i.Settings,
			&i.CurrentPhase,
			&i.CurrentPhaseStartedAt,
			&i.CurrentPhaseExpiresAt,
			&i.IsPaused,
			&i.LastGmActivityAt,
			&i.StorageUsedBytes,
			&i.SceneCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpiredTimeGateCampaigns = `-- name: GetExpiredTimeGateCampaigns :many
SELECT id, title, description, owner_id, settings, current_phase, current_phase_started_at, current_phase_expires_at, is_paused, last_gm_activity_at, storage_used_bytes, scene_count, created_at, updated_at FROM campaigns
WHERE current_phase = 'pc_phase'
  AND current_phase_expires_at IS NOT NULL
  AND current_phase_expires_at <= NOW()
  AND is_paused = false
`

func (q *Queries) GetExpiredTimeGateCampaigns(ctx context.Context) ([]Campaign, error) {
	rows, err := q.db.Query(ctx, getExpiredTimeGateCampaigns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Campaign
	for rows.Next() {
		var i Campaign
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.OwnerID,
			&i.Settings,
			&i.CurrentPhase,
			&i.CurrentPhaseStartedAt,
			&i.CurrentPhaseExpiresAt,
			&i.IsPaused,
			&i.LastGmActivityAt,
			&i.StorageUsedBytes,
			&i.SceneCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementCampaignStorage = `-- name: IncrementCampaignStorage :one
UPDATE campaigns
SET
    storage_used_bytes = storage_used_bytes + $2,
    updated_at = NOW()
WHERE id = $1
RETURNING storage_used_bytes
`

type IncrementCampaignStorageParams struct {
	ID               pgtype.UUID `json:"id"`
	StorageUsedBytes int64       `json:"storage_used_bytes"`
}

func (q *Queries) IncrementCampaignStorage(ctx context.Context, arg IncrementCampaignStorageParams) (int64, error) {
	row := q.db.QueryRow(ctx, incrementCampaignStorage, arg.ID, arg.StorageUsedBytes)
	var storage_used_bytes int64
	err := row.Scan(&storage_used_bytes)
	return storage_used_bytes, err
}

const isCampaignMember = `-- name: IsCampaignMember :one
SELECT EXISTS(
    SELECT 1 FROM campaign_members
    WHERE campaign_id = $1 AND user_id = $2
) AS is_member
`

type IsCampaignMemberParams struct {
	CampaignID pgtype.UUID `json:"campaign_id"`
	UserID     pgtype.UUID `json:"user_id"`
}

func (q *Queries) IsCampaignMember(ctx context.Context, arg IsCampaignMemberParams) (bool, error) {
	row := q.db.QueryRow(ctx, isCampaignMember, arg.CampaignID, arg.UserID)
	var is_member bool
	err := row.Scan(&is_member)
	return is_member, err
}

const isUserGM = `-- name: IsUserGM :one
SELECT EXISTS(
    SELECT 1 FROM campaign_members
    WHERE campaign_id = $1 AND user_id = $2 AND role = 'gm'
) AS is_gm
`

type IsUserGMParams struct {
	CampaignID pgtype.UUID `json:"campaign_id"`
	UserID     pgtype.UUID `json:"user_id"`
}

func (q *Queries) IsUserGM(ctx context.Context, arg IsUserGMParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserGM, arg.CampaignID, arg.UserID)
	var is_gm bool
	err := row.Scan(&is_gm)
	return is_gm, err
}

const listUserCampaigns = `-- name: ListUserCampaigns :many
SELECT
    c.id, c.title, c.description, c.owner_id, c.settings, c.current_phase, c.current_phase_started_at, c.current_phase_expires_at, c.is_paused, c.last_gm_activity_at, c.storage_used_bytes, c.scene_count, c.created_at, c.updated_at,
    cm.role as user_role
FROM campaigns c
INNER JOIN campaign_members cm ON c.id = cm.campaign_id
WHERE cm.user_id = $1
ORDER BY c.updated_at DESC
`

type ListUserCampaignsRow struct {
	ID                    pgtype.UUID        `json:"id"`
	Title                 string             `json:"title"`
	Description           pgtype.Text        `json:"description"`
	OwnerID               pgtype.UUID        `json:"owner_id"`
	Settings              []byte             `json:"settings"`
	CurrentPhase          CampaignPhase      `json:"current_phase"`
	CurrentPhaseStartedAt pgtype.Timestamptz `json:"current_phase_started_at"`
	CurrentPhaseExpiresAt pgtype.Timestamptz `json:"current_phase_expires_at"`
	IsPaused              bool               `json:"is_paused"`
	LastGmActivityAt      pgtype.Timestamptz `json:"last_gm_activity_at"`
	StorageUsedBytes      int64              `json:"storage_used_bytes"`
	SceneCount            int32              `json:"scene_count"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	UserRole              MemberRole         `json:"user_role"`
}

func (q *Queries) ListUserCampaigns(ctx context.Context, userID pgtype.UUID) ([]ListUserCampaignsRow, error) {
	rows, err := q.db.Query(ctx, listUserCampaigns, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserCampaignsRow
	for rows.Next() {
		var i ListUserCampaignsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.OwnerID,
			&i.Settings,
			&i.CurrentPhase,
			&i.CurrentPhaseStartedAt,
			&i.CurrentPhaseExpiresAt,
			&i.IsPaused,
			&i.LastGmActivityAt,
			&i.StorageUsedBytes,
			&i.SceneCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeCampaignMember = `-- name: RemoveCampaignMember :exec
DELETE FROM campaign_members
WHERE campaign_id = $1 AND user_id = $2
`

type RemoveCampaignMemberParams struct {
	CampaignID pgtype.UUID `json:"campaign_id"`
	UserID     pgtype.UUID `json:"user_id"`
}

func (q *Queries) RemoveCampaignMember(ctx context.Context, arg RemoveCampaignMemberParams) error {
	_, err := q.db.Exec(ctx, removeCampaignMember, arg.CampaignID, arg.UserID)
	return err
}

const transitionCampaignPhase = `-- name: TransitionCampaignPhase :one
UPDATE campaigns
SET
    current_phase = $2,
    current_phase_started_at = NOW(),
    current_phase_expires_at = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, title, description, owner_id, settings, current_phase, current_phase_started_at, current_phase_expires_at, is_paused, last_gm_activity_at, storage_used_bytes, scene_count, created_at, updated_at
`

type TransitionCampaignPhaseParams struct {
	ID                    pgtype.UUID        `json:"id"`
	CurrentPhase          CampaignPhase      `json:"current_phase"`
	CurrentPhaseExpiresAt pgtype.Timestamptz `json:"current_phase_expires_at"`
}

func (q *Queries) TransitionCampaignPhase(ctx context.Context, arg TransitionCampaignPhaseParams) (Campaign, error) {
	row := q.db.QueryRow(ctx, transitionCampaignPhase, arg.ID, arg.CurrentPhase, arg.CurrentPhaseExpiresAt)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.OwnerID,
		&i.Settings,
		&i.CurrentPhase,
		&i.CurrentPhaseStartedAt,
		&i.CurrentPhaseExpiresAt,
		&i.IsPaused,
		&i.LastGmActivityAt,
		&i.StorageUsedBytes,
		&i.SceneCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCampaign = `-- name: UpdateCampaign :one
UPDATE campaigns
SET
    title = COALESCE($2, title),
    description = COALESCE($3, description),
    settings = COALESCE($4, settings),
    updated_at = NOW()
WHERE id = $1
RETURNING id, title, description, owner_id, settings, current_phase, current_phase_started_at, current_phase_expires_at, is_paused, last_gm_activity_at, storage_used_bytes, scene_count, created_at, updated_at
`

type UpdateCampaignParams struct {
	ID          pgtype.UUID `json:"id"`
	Title       string      `json:"title"`
	Description pgtype.Text `json:"description"`
	Settings    []byte      `json:"settings"`
}

func (q *Queries) UpdateCampaign(ctx context.Context, arg UpdateCampaignParams) (Campaign, error) {
	row := q.db.QueryRow(ctx, updateCampaign,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Settings,
	)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.OwnerID,
		&i.Settings,
		&i.CurrentPhase,
		&i.CurrentPhaseStartedAt,
		&i.CurrentPhaseExpiresAt,
		&i.IsPaused,
		&i.LastGmActivityAt,
		&i.StorageUsedBytes,
		&i.SceneCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCampaignOwner = `-- name: UpdateCampaignOwner :one
UPDATE campaigns
SET
    owner_id = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, title, description, owner_id, settings, current_phase, current_phase_started_at, current_phase_expires_at, is_paused, last_gm_activity_at, storage_used_bytes, scene_count, created_at, updated_at
`

type UpdateCampaignOwnerParams struct {
	ID      pgtype.UUID `json:"id"`
	OwnerID pgtype.UUID `json:"owner_id"`
}

func (q *Queries) UpdateCampaignOwner(ctx context.Context, arg UpdateCampaignOwnerParams) (Campaign, error) {
	row := q.db.QueryRow(ctx, updateCampaignOwner, arg.ID, arg.OwnerID)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.OwnerID,
		&i.Settings,
		&i.CurrentPhase,
		&i.CurrentPhaseStartedAt,
		&i.CurrentPhaseExpiresAt,
		&i.IsPaused,
		&i.LastGmActivityAt,
		&i.StorageUsedBytes,
		&i.SceneCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCampaignPausedState = `-- name: UpdateCampaignPausedState :one
UPDATE campaigns
SET
    is_paused = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, title, description, owner_id, settings, current_phase, current_phase_started_at, current_phase_expires_at, is_paused, last_gm_activity_at, storage_used_bytes, scene_count, created_at, updated_at
`

type UpdateCampaignPausedStateParams struct {
	ID       pgtype.UUID `json:"id"`
	IsPaused bool        `json:"is_paused"`
}

func (q *Queries) UpdateCampaignPausedState(ctx context.Context, arg UpdateCampaignPausedStateParams) (Campaign, error) {
	row := q.db.QueryRow(ctx, updateCampaignPausedState, arg.ID, arg.IsPaused)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.OwnerID,
		&i.Settings,
		&i.CurrentPhase,
		&i.CurrentPhaseStartedAt,
		&i.CurrentPhaseExpiresAt,
		&i.IsPaused,
		&i.LastGmActivityAt,
		&i.StorageUsedBytes,
		&i.SceneCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCampaignPhase = `-- name: UpdateCampaignPhase :exec
UPDATE campaigns
SET
    current_phase = $2,
    current_phase_started_at = NOW(),
    current_phase_expires_at = $3,
    updated_at = NOW()
WHERE id = $1
`

type UpdateCampaignPhaseParams struct {
	ID                    pgtype.UUID        `json:"id"`
	CurrentPhase          CampaignPhase      `json:"current_phase"`
	CurrentPhaseExpiresAt pgtype.Timestamptz `json:"current_phase_expires_at"`
}

func (q *Queries) UpdateCampaignPhase(ctx context.Context, arg UpdateCampaignPhaseParams) error {
	_, err := q.db.Exec(ctx, updateCampaignPhase, arg.ID, arg.CurrentPhase, arg.CurrentPhaseExpiresAt)
	return err
}

const updateGmActivity = `-- name: UpdateGmActivity :exec
UPDATE campaigns
SET last_gm_activity_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateGmActivity(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateGmActivity, id)
	return err
}

const updateMemberRole = `-- name: UpdateMemberRole :exec
UPDATE campaign_members
SET role = $3
WHERE campaign_id = $1 AND user_id = $2
`

type UpdateMemberRoleParams struct {
	CampaignID pgtype.UUID `json:"campaign_id"`
	UserID     pgtype.UUID `json:"user_id"`
	Role       MemberRole  `json:"role"`
}

func (q *Queries) UpdateMemberRole(ctx context.Context, arg UpdateMemberRoleParams) error {
	_, err := q.db.Exec(ctx, updateMemberRole, arg.CampaignID, arg.UserID, arg.Role)
	return err
}
