// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: characters.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const archiveCharacter = `-- name: ArchiveCharacter :one
UPDATE characters
SET
    is_archived = true,
    updated_at = NOW()
WHERE id = $1
RETURNING id, campaign_id, display_name, description, avatar_url, character_type, is_archived, created_at, updated_at
`

func (q *Queries) ArchiveCharacter(ctx context.Context, id pgtype.UUID) (Character, error) {
	row := q.db.QueryRow(ctx, archiveCharacter, id)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.DisplayName,
		&i.Description,
		&i.AvatarUrl,
		&i.CharacterType,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const assignCharacter = `-- name: AssignCharacter :one
INSERT INTO character_assignments (
    character_id,
    user_id
) VALUES (
    $1, $2
)
ON CONFLICT (character_id) DO UPDATE
SET
    user_id = $2,
    assigned_at = NOW()
RETURNING id, character_id, user_id, assigned_at
`

type AssignCharacterParams struct {
	CharacterID pgtype.UUID `json:"character_id"`
	UserID      pgtype.UUID `json:"user_id"`
}

func (q *Queries) AssignCharacter(ctx context.Context, arg AssignCharacterParams) (CharacterAssignment, error) {
	row := q.db.QueryRow(ctx, assignCharacter, arg.CharacterID, arg.UserID)
	var i CharacterAssignment
	err := row.Scan(
		&i.ID,
		&i.CharacterID,
		&i.UserID,
		&i.AssignedAt,
	)
	return i, err
}

const clearCharacterAvatar = `-- name: ClearCharacterAvatar :one
UPDATE characters
SET
    avatar_url = NULL,
    updated_at = NOW()
WHERE id = $1
RETURNING id, campaign_id, display_name, description, avatar_url, character_type, is_archived, created_at, updated_at
`

func (q *Queries) ClearCharacterAvatar(ctx context.Context, id pgtype.UUID) (Character, error) {
	row := q.db.QueryRow(ctx, clearCharacterAvatar, id)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.DisplayName,
		&i.Description,
		&i.AvatarUrl,
		&i.CharacterType,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countCampaignCharacters = `-- name: CountCampaignCharacters :one
SELECT COUNT(*) FROM characters WHERE campaign_id = $1
`

func (q *Queries) CountCampaignCharacters(ctx context.Context, campaignID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countCampaignCharacters, campaignID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCharacter = `-- name: CreateCharacter :one
INSERT INTO characters (
    campaign_id,
    display_name,
    description,
    character_type
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, campaign_id, display_name, description, avatar_url, character_type, is_archived, created_at, updated_at
`

type CreateCharacterParams struct {
	CampaignID    pgtype.UUID   `json:"campaign_id"`
	DisplayName   string        `json:"display_name"`
	Description   pgtype.Text   `json:"description"`
	CharacterType CharacterType `json:"character_type"`
}

func (q *Queries) CreateCharacter(ctx context.Context, arg CreateCharacterParams) (Character, error) {
	row := q.db.QueryRow(ctx, createCharacter,
		arg.CampaignID,
		arg.DisplayName,
		arg.Description,
		arg.CharacterType,
	)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.DisplayName,
		&i.Description,
		&i.AvatarUrl,
		&i.CharacterType,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCharacter = `-- name: GetCharacter :one
SELECT id, campaign_id, display_name, description, avatar_url, character_type, is_archived, created_at, updated_at FROM characters WHERE id = $1
`

func (q *Queries) GetCharacter(ctx context.Context, id pgtype.UUID) (Character, error) {
	row := q.db.QueryRow(ctx, getCharacter, id)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.DisplayName,
		&i.Description,
		&i.AvatarUrl,
		&i.CharacterType,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCharacterAssignment = `-- name: GetCharacterAssignment :one
SELECT id, character_id, user_id, assigned_at FROM character_assignments WHERE character_id = $1
`

func (q *Queries) GetCharacterAssignment(ctx context.Context, characterID pgtype.UUID) (CharacterAssignment, error) {
	row := q.db.QueryRow(ctx, getCharacterAssignment, characterID)
	var i CharacterAssignment
	err := row.Scan(
		&i.ID,
		&i.CharacterID,
		&i.UserID,
		&i.AssignedAt,
	)
	return i, err
}

const getCharacterCampaignID = `-- name: GetCharacterCampaignID :one
SELECT campaign_id FROM characters WHERE id = $1
`

func (q *Queries) GetCharacterCampaignID(ctx context.Context, id pgtype.UUID) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getCharacterCampaignID, id)
	var campaign_id pgtype.UUID
	err := row.Scan(&campaign_id)
	return campaign_id, err
}

const getCharacterWithAssignment = `-- name: GetCharacterWithAssignment :one
SELECT
    c.id, c.campaign_id, c.display_name, c.description, c.avatar_url, c.character_type, c.is_archived, c.created_at, c.updated_at,
    ca.user_id AS assigned_user_id,
    ca.assigned_at
FROM characters c
LEFT JOIN character_assignments ca ON c.id = ca.character_id
WHERE c.id = $1
`

type GetCharacterWithAssignmentRow struct {
	ID             pgtype.UUID        `json:"id"`
	CampaignID     pgtype.UUID        `json:"campaign_id"`
	DisplayName    string             `json:"display_name"`
	Description    pgtype.Text        `json:"description"`
	AvatarUrl      pgtype.Text        `json:"avatar_url"`
	CharacterType  CharacterType      `json:"character_type"`
	IsArchived     bool               `json:"is_archived"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	AssignedUserID pgtype.UUID        `json:"assigned_user_id"`
	AssignedAt     pgtype.Timestamptz `json:"assigned_at"`
}

func (q *Queries) GetCharacterWithAssignment(ctx context.Context, id pgtype.UUID) (GetCharacterWithAssignmentRow, error) {
	row := q.db.QueryRow(ctx, getCharacterWithAssignment, id)
	var i GetCharacterWithAssignmentRow
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.DisplayName,
		&i.Description,
		&i.AvatarUrl,
		&i.CharacterType,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AssignedUserID,
		&i.AssignedAt,
	)
	return i, err
}

const getOrphanedCharacters = `-- name: GetOrphanedCharacters :many
SELECT c.id, c.campaign_id, c.display_name, c.description, c.avatar_url, c.character_type, c.is_archived, c.created_at, c.updated_at
FROM characters c
LEFT JOIN character_assignments ca ON c.id = ca.character_id
WHERE c.campaign_id = $1 AND ca.id IS NULL AND c.is_archived = false
ORDER BY c.created_at ASC
`

func (q *Queries) GetOrphanedCharacters(ctx context.Context, campaignID pgtype.UUID) ([]Character, error) {
	rows, err := q.db.Query(ctx, getOrphanedCharacters, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Character
	for rows.Next() {
		var i Character
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.DisplayName,
			&i.Description,
			&i.AvatarUrl,
			&i.CharacterType,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCharactersInScene = `-- name: GetUserCharactersInScene :many
SELECT
    c.id, c.campaign_id, c.display_name, c.description, c.avatar_url, c.character_type, c.is_archived, c.created_at, c.updated_at,
    ca.user_id AS assigned_user_id,
    ca.assigned_at
FROM characters c
INNER JOIN character_assignments ca ON c.id = ca.character_id
WHERE c.id = ANY(
    SELECT unnest(character_ids) FROM scenes WHERE scenes.id = $1
)
AND ca.user_id = $2
AND c.is_archived = false
ORDER BY c.display_name
`

type GetUserCharactersInSceneParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

type GetUserCharactersInSceneRow struct {
	ID             pgtype.UUID        `json:"id"`
	CampaignID     pgtype.UUID        `json:"campaign_id"`
	DisplayName    string             `json:"display_name"`
	Description    pgtype.Text        `json:"description"`
	AvatarUrl      pgtype.Text        `json:"avatar_url"`
	CharacterType  CharacterType      `json:"character_type"`
	IsArchived     bool               `json:"is_archived"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	AssignedUserID pgtype.UUID        `json:"assigned_user_id"`
	AssignedAt     pgtype.Timestamptz `json:"assigned_at"`
}

func (q *Queries) GetUserCharactersInScene(ctx context.Context, arg GetUserCharactersInSceneParams) ([]GetUserCharactersInSceneRow, error) {
	rows, err := q.db.Query(ctx, getUserCharactersInScene, arg.ID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserCharactersInSceneRow
	for rows.Next() {
		var i GetUserCharactersInSceneRow
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.DisplayName,
			&i.Description,
			&i.AvatarUrl,
			&i.CharacterType,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AssignedUserID,
			&i.AssignedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCampaignCharacters = `-- name: ListCampaignCharacters :many
SELECT
    c.id, c.campaign_id, c.display_name, c.description, c.avatar_url, c.character_type, c.is_archived, c.created_at, c.updated_at,
    ca.user_id AS assigned_user_id,
    ca.assigned_at
FROM characters c
LEFT JOIN character_assignments ca ON c.id = ca.character_id
WHERE c.campaign_id = $1
ORDER BY c.is_archived ASC, c.created_at ASC
`

type ListCampaignCharactersRow struct {
	ID             pgtype.UUID        `json:"id"`
	CampaignID     pgtype.UUID        `json:"campaign_id"`
	DisplayName    string             `json:"display_name"`
	Description    pgtype.Text        `json:"description"`
	AvatarUrl      pgtype.Text        `json:"avatar_url"`
	CharacterType  CharacterType      `json:"character_type"`
	IsArchived     bool               `json:"is_archived"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	AssignedUserID pgtype.UUID        `json:"assigned_user_id"`
	AssignedAt     pgtype.Timestamptz `json:"assigned_at"`
}

func (q *Queries) ListCampaignCharacters(ctx context.Context, campaignID pgtype.UUID) ([]ListCampaignCharactersRow, error) {
	rows, err := q.db.Query(ctx, listCampaignCharacters, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCampaignCharactersRow
	for rows.Next() {
		var i ListCampaignCharactersRow
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.DisplayName,
			&i.Description,
			&i.AvatarUrl,
			&i.CharacterType,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AssignedUserID,
			&i.AssignedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserCharactersInCampaign = `-- name: ListUserCharactersInCampaign :many
SELECT
    c.id, c.campaign_id, c.display_name, c.description, c.avatar_url, c.character_type, c.is_archived, c.created_at, c.updated_at,
    ca.user_id AS assigned_user_id,
    ca.assigned_at
FROM characters c
INNER JOIN character_assignments ca ON c.id = ca.character_id
WHERE c.campaign_id = $1 AND ca.user_id = $2 AND c.is_archived = false
ORDER BY c.created_at ASC
`

type ListUserCharactersInCampaignParams struct {
	CampaignID pgtype.UUID `json:"campaign_id"`
	UserID     pgtype.UUID `json:"user_id"`
}

type ListUserCharactersInCampaignRow struct {
	ID             pgtype.UUID        `json:"id"`
	CampaignID     pgtype.UUID        `json:"campaign_id"`
	DisplayName    string             `json:"display_name"`
	Description    pgtype.Text        `json:"description"`
	AvatarUrl      pgtype.Text        `json:"avatar_url"`
	CharacterType  CharacterType      `json:"character_type"`
	IsArchived     bool               `json:"is_archived"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	AssignedUserID pgtype.UUID        `json:"assigned_user_id"`
	AssignedAt     pgtype.Timestamptz `json:"assigned_at"`
}

func (q *Queries) ListUserCharactersInCampaign(ctx context.Context, arg ListUserCharactersInCampaignParams) ([]ListUserCharactersInCampaignRow, error) {
	rows, err := q.db.Query(ctx, listUserCharactersInCampaign, arg.CampaignID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserCharactersInCampaignRow
	for rows.Next() {
		var i ListUserCharactersInCampaignRow
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.DisplayName,
			&i.Description,
			&i.AvatarUrl,
			&i.CharacterType,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AssignedUserID,
			&i.AssignedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unarchiveCharacter = `-- name: UnarchiveCharacter :one
UPDATE characters
SET
    is_archived = false,
    updated_at = NOW()
WHERE id = $1
RETURNING id, campaign_id, display_name, description, avatar_url, character_type, is_archived, created_at, updated_at
`

func (q *Queries) UnarchiveCharacter(ctx context.Context, id pgtype.UUID) (Character, error) {
	row := q.db.QueryRow(ctx, unarchiveCharacter, id)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.DisplayName,
		&i.Description,
		&i.AvatarUrl,
		&i.CharacterType,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const unassignCharacter = `-- name: UnassignCharacter :exec
DELETE FROM character_assignments WHERE character_id = $1
`

func (q *Queries) UnassignCharacter(ctx context.Context, characterID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, unassignCharacter, characterID)
	return err
}

const updateCharacter = `-- name: UpdateCharacter :one
UPDATE characters
SET
    display_name = COALESCE($2, display_name),
    description = COALESCE($3, description),
    avatar_url = COALESCE($4, avatar_url),
    character_type = COALESCE($5, character_type),
    updated_at = NOW()
WHERE id = $1
RETURNING id, campaign_id, display_name, description, avatar_url, character_type, is_archived, created_at, updated_at
`

type UpdateCharacterParams struct {
	ID            pgtype.UUID   `json:"id"`
	DisplayName   string        `json:"display_name"`
	Description   pgtype.Text   `json:"description"`
	AvatarUrl     pgtype.Text   `json:"avatar_url"`
	CharacterType CharacterType `json:"character_type"`
}

func (q *Queries) UpdateCharacter(ctx context.Context, arg UpdateCharacterParams) (Character, error) {
	row := q.db.QueryRow(ctx, updateCharacter,
		arg.ID,
		arg.DisplayName,
		arg.Description,
		arg.AvatarUrl,
		arg.CharacterType,
	)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.DisplayName,
		&i.Description,
		&i.AvatarUrl,
		&i.CharacterType,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCharacterAvatar = `-- name: UpdateCharacterAvatar :one
UPDATE characters
SET
    avatar_url = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, campaign_id, display_name, description, avatar_url, character_type, is_archived, created_at, updated_at
`

type UpdateCharacterAvatarParams struct {
	ID        pgtype.UUID `json:"id"`
	AvatarUrl pgtype.Text `json:"avatar_url"`
}

func (q *Queries) UpdateCharacterAvatar(ctx context.Context, arg UpdateCharacterAvatarParams) (Character, error) {
	row := q.db.QueryRow(ctx, updateCharacterAvatar, arg.ID, arg.AvatarUrl)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.DisplayName,
		&i.Description,
		&i.AvatarUrl,
		&i.CharacterType,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
