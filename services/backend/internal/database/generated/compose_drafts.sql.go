// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: compose_drafts.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createComposeDraft = `-- name: CreateComposeDraft :one
INSERT INTO compose_drafts (
    scene_id,
    character_id,
    user_id,
    blocks,
    ooc_text,
    intention,
    modifier,
    is_hidden
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, scene_id, character_id, user_id, blocks, ooc_text, intention, modifier, is_hidden, updated_at
`

type CreateComposeDraftParams struct {
	SceneID     pgtype.UUID `json:"scene_id"`
	CharacterID pgtype.UUID `json:"character_id"`
	UserID      pgtype.UUID `json:"user_id"`
	Blocks      []byte      `json:"blocks"`
	OocText     pgtype.Text `json:"ooc_text"`
	Intention   pgtype.Text `json:"intention"`
	Modifier    pgtype.Int4 `json:"modifier"`
	IsHidden    bool        `json:"is_hidden"`
}

func (q *Queries) CreateComposeDraft(ctx context.Context, arg CreateComposeDraftParams) (ComposeDraft, error) {
	row := q.db.QueryRow(ctx, createComposeDraft,
		arg.SceneID,
		arg.CharacterID,
		arg.UserID,
		arg.Blocks,
		arg.OocText,
		arg.Intention,
		arg.Modifier,
		arg.IsHidden,
	)
	var i ComposeDraft
	err := row.Scan(
		&i.ID,
		&i.SceneID,
		&i.CharacterID,
		&i.UserID,
		&i.Blocks,
		&i.OocText,
		&i.Intention,
		&i.Modifier,
		&i.IsHidden,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteComposeDraft = `-- name: DeleteComposeDraft :exec
DELETE FROM compose_drafts WHERE id = $1
`

func (q *Queries) DeleteComposeDraft(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteComposeDraft, id)
	return err
}

const deleteComposeDraftByCharacter = `-- name: DeleteComposeDraftByCharacter :exec
DELETE FROM compose_drafts
WHERE scene_id = $1 AND character_id = $2
`

type DeleteComposeDraftByCharacterParams struct {
	SceneID     pgtype.UUID `json:"scene_id"`
	CharacterID pgtype.UUID `json:"character_id"`
}

func (q *Queries) DeleteComposeDraftByCharacter(ctx context.Context, arg DeleteComposeDraftByCharacterParams) error {
	_, err := q.db.Exec(ctx, deleteComposeDraftByCharacter, arg.SceneID, arg.CharacterID)
	return err
}

const getComposeDraft = `-- name: GetComposeDraft :one
SELECT id, scene_id, character_id, user_id, blocks, ooc_text, intention, modifier, is_hidden, updated_at FROM compose_drafts
WHERE scene_id = $1 AND character_id = $2
`

type GetComposeDraftParams struct {
	SceneID     pgtype.UUID `json:"scene_id"`
	CharacterID pgtype.UUID `json:"character_id"`
}

func (q *Queries) GetComposeDraft(ctx context.Context, arg GetComposeDraftParams) (ComposeDraft, error) {
	row := q.db.QueryRow(ctx, getComposeDraft, arg.SceneID, arg.CharacterID)
	var i ComposeDraft
	err := row.Scan(
		&i.ID,
		&i.SceneID,
		&i.CharacterID,
		&i.UserID,
		&i.Blocks,
		&i.OocText,
		&i.Intention,
		&i.Modifier,
		&i.IsHidden,
		&i.UpdatedAt,
	)
	return i, err
}

const getComposeDraftByID = `-- name: GetComposeDraftByID :one
SELECT id, scene_id, character_id, user_id, blocks, ooc_text, intention, modifier, is_hidden, updated_at FROM compose_drafts
WHERE id = $1
`

func (q *Queries) GetComposeDraftByID(ctx context.Context, id pgtype.UUID) (ComposeDraft, error) {
	row := q.db.QueryRow(ctx, getComposeDraftByID, id)
	var i ComposeDraft
	err := row.Scan(
		&i.ID,
		&i.SceneID,
		&i.CharacterID,
		&i.UserID,
		&i.Blocks,
		&i.OocText,
		&i.Intention,
		&i.Modifier,
		&i.IsHidden,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserDraftInScene = `-- name: GetUserDraftInScene :one
SELECT id, scene_id, character_id, user_id, blocks, ooc_text, intention, modifier, is_hidden, updated_at FROM compose_drafts
WHERE scene_id = $1 AND character_id = $2 AND user_id = $3
`

type GetUserDraftInSceneParams struct {
	SceneID     pgtype.UUID `json:"scene_id"`
	CharacterID pgtype.UUID `json:"character_id"`
	UserID      pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetUserDraftInScene(ctx context.Context, arg GetUserDraftInSceneParams) (ComposeDraft, error) {
	row := q.db.QueryRow(ctx, getUserDraftInScene, arg.SceneID, arg.CharacterID, arg.UserID)
	var i ComposeDraft
	err := row.Scan(
		&i.ID,
		&i.SceneID,
		&i.CharacterID,
		&i.UserID,
		&i.Blocks,
		&i.OocText,
		&i.Intention,
		&i.Modifier,
		&i.IsHidden,
		&i.UpdatedAt,
	)
	return i, err
}

const listUserDrafts = `-- name: ListUserDrafts :many
SELECT cd.id, cd.scene_id, cd.character_id, cd.user_id, cd.blocks, cd.ooc_text, cd.intention, cd.modifier, cd.is_hidden, cd.updated_at, s.title AS scene_title, c.display_name AS character_name
FROM compose_drafts cd
INNER JOIN scenes s ON cd.scene_id = s.id
INNER JOIN characters c ON cd.character_id = c.id
WHERE cd.user_id = $1
ORDER BY cd.updated_at DESC
`

type ListUserDraftsRow struct {
	ID            pgtype.UUID        `json:"id"`
	SceneID       pgtype.UUID        `json:"scene_id"`
	CharacterID   pgtype.UUID        `json:"character_id"`
	UserID        pgtype.UUID        `json:"user_id"`
	Blocks        []byte             `json:"blocks"`
	OocText       pgtype.Text        `json:"ooc_text"`
	Intention     pgtype.Text        `json:"intention"`
	Modifier      pgtype.Int4        `json:"modifier"`
	IsHidden      bool               `json:"is_hidden"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	SceneTitle    string             `json:"scene_title"`
	CharacterName string             `json:"character_name"`
}

func (q *Queries) ListUserDrafts(ctx context.Context, userID pgtype.UUID) ([]ListUserDraftsRow, error) {
	rows, err := q.db.Query(ctx, listUserDrafts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserDraftsRow
	for rows.Next() {
		var i ListUserDraftsRow
		if err := rows.Scan(
			&i.ID,
			&i.SceneID,
			&i.CharacterID,
			&i.UserID,
			&i.Blocks,
			&i.OocText,
			&i.Intention,
			&i.Modifier,
			&i.IsHidden,
			&i.UpdatedAt,
			&i.SceneTitle,
			&i.CharacterName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateComposeDraft = `-- name: UpdateComposeDraft :one
UPDATE compose_drafts
SET
    blocks = $2,
    ooc_text = $3,
    intention = $4,
    modifier = $5,
    is_hidden = $6,
    updated_at = NOW()
WHERE id = $1
RETURNING id, scene_id, character_id, user_id, blocks, ooc_text, intention, modifier, is_hidden, updated_at
`

type UpdateComposeDraftParams struct {
	ID        pgtype.UUID `json:"id"`
	Blocks    []byte      `json:"blocks"`
	OocText   pgtype.Text `json:"ooc_text"`
	Intention pgtype.Text `json:"intention"`
	Modifier  pgtype.Int4 `json:"modifier"`
	IsHidden  bool        `json:"is_hidden"`
}

func (q *Queries) UpdateComposeDraft(ctx context.Context, arg UpdateComposeDraftParams) (ComposeDraft, error) {
	row := q.db.QueryRow(ctx, updateComposeDraft,
		arg.ID,
		arg.Blocks,
		arg.OocText,
		arg.Intention,
		arg.Modifier,
		arg.IsHidden,
	)
	var i ComposeDraft
	err := row.Scan(
		&i.ID,
		&i.SceneID,
		&i.CharacterID,
		&i.UserID,
		&i.Blocks,
		&i.OocText,
		&i.Intention,
		&i.Modifier,
		&i.IsHidden,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertComposeDraft = `-- name: UpsertComposeDraft :one
INSERT INTO compose_drafts (
    scene_id,
    character_id,
    user_id,
    blocks,
    ooc_text,
    intention,
    modifier,
    is_hidden
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
ON CONFLICT (scene_id, character_id)
DO UPDATE SET
    blocks = EXCLUDED.blocks,
    ooc_text = EXCLUDED.ooc_text,
    intention = EXCLUDED.intention,
    modifier = EXCLUDED.modifier,
    is_hidden = EXCLUDED.is_hidden,
    updated_at = NOW()
RETURNING id, scene_id, character_id, user_id, blocks, ooc_text, intention, modifier, is_hidden, updated_at
`

type UpsertComposeDraftParams struct {
	SceneID     pgtype.UUID `json:"scene_id"`
	CharacterID pgtype.UUID `json:"character_id"`
	UserID      pgtype.UUID `json:"user_id"`
	Blocks      []byte      `json:"blocks"`
	OocText     pgtype.Text `json:"ooc_text"`
	Intention   pgtype.Text `json:"intention"`
	Modifier    pgtype.Int4 `json:"modifier"`
	IsHidden    bool        `json:"is_hidden"`
}

func (q *Queries) UpsertComposeDraft(ctx context.Context, arg UpsertComposeDraftParams) (ComposeDraft, error) {
	row := q.db.QueryRow(ctx, upsertComposeDraft,
		arg.SceneID,
		arg.CharacterID,
		arg.UserID,
		arg.Blocks,
		arg.OocText,
		arg.Intention,
		arg.Modifier,
		arg.IsHidden,
	)
	var i ComposeDraft
	err := row.Scan(
		&i.ID,
		&i.SceneID,
		&i.CharacterID,
		&i.UserID,
		&i.Blocks,
		&i.OocText,
		&i.Intention,
		&i.Modifier,
		&i.IsHidden,
		&i.UpdatedAt,
	)
	return i, err
}
