// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: rolls.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const characterHasPendingRolls = `-- name: CharacterHasPendingRolls :one
SELECT EXISTS(
    SELECT 1 FROM rolls
    WHERE character_id = $1
      AND status = 'pending'
) AS has_pending
`

func (q *Queries) CharacterHasPendingRolls(ctx context.Context, characterID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, characterHasPendingRolls, characterID)
	var has_pending bool
	err := row.Scan(&has_pending)
	return has_pending, err
}

const countPendingRollsForCharacter = `-- name: CountPendingRollsForCharacter :one
SELECT COUNT(*)
FROM rolls
WHERE character_id = $1
  AND status = 'pending'
`

func (q *Queries) CountPendingRollsForCharacter(ctx context.Context, characterID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPendingRollsForCharacter, characterID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRoll = `-- name: CreateRoll :one

INSERT INTO rolls (
    post_id,
    scene_id,
    character_id,
    requested_by,
    intention,
    modifier,
    dice_type,
    dice_count,
    status
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 'pending')
RETURNING id, post_id, scene_id, character_id, requested_by, intention, modifier, dice_type, dice_count, result, total, was_overridden, original_intention, status, created_at, overridden_by, override_reason, override_timestamp, manual_result, manually_resolved_by, manual_resolution_reason, rolled_at
`

type CreateRollParams struct {
	PostID      pgtype.UUID `json:"post_id"`
	SceneID     pgtype.UUID `json:"scene_id"`
	CharacterID pgtype.UUID `json:"character_id"`
	RequestedBy pgtype.UUID `json:"requested_by"`
	Intention   string      `json:"intention"`
	Modifier    int32       `json:"modifier"`
	DiceType    string      `json:"dice_type"`
	DiceCount   int32       `json:"dice_count"`
}

// ============================================
// DICE ROLLS QUERIES
// ============================================
func (q *Queries) CreateRoll(ctx context.Context, arg CreateRollParams) (Roll, error) {
	row := q.db.QueryRow(ctx, createRoll,
		arg.PostID,
		arg.SceneID,
		arg.CharacterID,
		arg.RequestedBy,
		arg.Intention,
		arg.Modifier,
		arg.DiceType,
		arg.DiceCount,
	)
	var i Roll
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.SceneID,
		&i.CharacterID,
		&i.RequestedBy,
		&i.Intention,
		&i.Modifier,
		&i.DiceType,
		&i.DiceCount,
		&i.Result,
		&i.Total,
		&i.WasOverridden,
		&i.OriginalIntention,
		&i.Status,
		&i.CreatedAt,
		&i.OverriddenBy,
		&i.OverrideReason,
		&i.OverrideTimestamp,
		&i.ManualResult,
		&i.ManuallyResolvedBy,
		&i.ManualResolutionReason,
		&i.RolledAt,
	)
	return i, err
}

const deleteRoll = `-- name: DeleteRoll :exec
DELETE FROM rolls WHERE id = $1
`

func (q *Queries) DeleteRoll(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteRoll, id)
	return err
}

const executeRoll = `-- name: ExecuteRoll :one
UPDATE rolls
SET
    result = $2,
    total = $3,
    rolled_at = NOW(),
    status = 'completed'
WHERE id = $1
RETURNING id, post_id, scene_id, character_id, requested_by, intention, modifier, dice_type, dice_count, result, total, was_overridden, original_intention, status, created_at, overridden_by, override_reason, override_timestamp, manual_result, manually_resolved_by, manual_resolution_reason, rolled_at
`

type ExecuteRollParams struct {
	ID     pgtype.UUID `json:"id"`
	Result []int32     `json:"result"`
	Total  pgtype.Int4 `json:"total"`
}

func (q *Queries) ExecuteRoll(ctx context.Context, arg ExecuteRollParams) (Roll, error) {
	row := q.db.QueryRow(ctx, executeRoll, arg.ID, arg.Result, arg.Total)
	var i Roll
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.SceneID,
		&i.CharacterID,
		&i.RequestedBy,
		&i.Intention,
		&i.Modifier,
		&i.DiceType,
		&i.DiceCount,
		&i.Result,
		&i.Total,
		&i.WasOverridden,
		&i.OriginalIntention,
		&i.Status,
		&i.CreatedAt,
		&i.OverriddenBy,
		&i.OverrideReason,
		&i.OverrideTimestamp,
		&i.ManualResult,
		&i.ManuallyResolvedBy,
		&i.ManualResolutionReason,
		&i.RolledAt,
	)
	return i, err
}

const getPendingRollsForCharacter = `-- name: GetPendingRollsForCharacter :many
SELECT r.id, r.post_id, r.scene_id, r.character_id, r.requested_by, r.intention, r.modifier, r.dice_type, r.dice_count, r.result, r.total, r.was_overridden, r.original_intention, r.status, r.created_at, r.overridden_by, r.override_reason, r.override_timestamp, r.manual_result, r.manually_resolved_by, r.manual_resolution_reason, r.rolled_at
FROM rolls r
WHERE r.character_id = $1
  AND r.status = 'pending'
ORDER BY r.created_at DESC
`

func (q *Queries) GetPendingRollsForCharacter(ctx context.Context, characterID pgtype.UUID) ([]Roll, error) {
	rows, err := q.db.Query(ctx, getPendingRollsForCharacter, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Roll
	for rows.Next() {
		var i Roll
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.SceneID,
			&i.CharacterID,
			&i.RequestedBy,
			&i.Intention,
			&i.Modifier,
			&i.DiceType,
			&i.DiceCount,
			&i.Result,
			&i.Total,
			&i.WasOverridden,
			&i.OriginalIntention,
			&i.Status,
			&i.CreatedAt,
			&i.OverriddenBy,
			&i.OverrideReason,
			&i.OverrideTimestamp,
			&i.ManualResult,
			&i.ManuallyResolvedBy,
			&i.ManualResolutionReason,
			&i.RolledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingRollsInScene = `-- name: GetPendingRollsInScene :many
SELECT
    r.id, r.post_id, r.scene_id, r.character_id, r.requested_by, r.intention, r.modifier, r.dice_type, r.dice_count, r.result, r.total, r.was_overridden, r.original_intention, r.status, r.created_at, r.overridden_by, r.override_reason, r.override_timestamp, r.manual_result, r.manually_resolved_by, r.manual_resolution_reason, r.rolled_at,
    c.display_name AS character_name
FROM rolls r
JOIN characters c ON c.id = r.character_id
WHERE r.scene_id = $1
  AND r.status = 'pending'
ORDER BY r.created_at ASC
`

type GetPendingRollsInSceneRow struct {
	ID                     pgtype.UUID        `json:"id"`
	PostID                 pgtype.UUID        `json:"post_id"`
	SceneID                pgtype.UUID        `json:"scene_id"`
	CharacterID            pgtype.UUID        `json:"character_id"`
	RequestedBy            pgtype.UUID        `json:"requested_by"`
	Intention              string             `json:"intention"`
	Modifier               int32              `json:"modifier"`
	DiceType               string             `json:"dice_type"`
	DiceCount              int32              `json:"dice_count"`
	Result                 []int32            `json:"result"`
	Total                  pgtype.Int4        `json:"total"`
	WasOverridden          bool               `json:"was_overridden"`
	OriginalIntention      pgtype.Text        `json:"original_intention"`
	Status                 RollStatus         `json:"status"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	OverriddenBy           pgtype.UUID        `json:"overridden_by"`
	OverrideReason         pgtype.Text        `json:"override_reason"`
	OverrideTimestamp      pgtype.Timestamptz `json:"override_timestamp"`
	ManualResult           pgtype.Int4        `json:"manual_result"`
	ManuallyResolvedBy     pgtype.UUID        `json:"manually_resolved_by"`
	ManualResolutionReason pgtype.Text        `json:"manual_resolution_reason"`
	RolledAt               pgtype.Timestamptz `json:"rolled_at"`
	CharacterName          string             `json:"character_name"`
}

func (q *Queries) GetPendingRollsInScene(ctx context.Context, sceneID pgtype.UUID) ([]GetPendingRollsInSceneRow, error) {
	rows, err := q.db.Query(ctx, getPendingRollsInScene, sceneID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingRollsInSceneRow
	for rows.Next() {
		var i GetPendingRollsInSceneRow
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.SceneID,
			&i.CharacterID,
			&i.RequestedBy,
			&i.Intention,
			&i.Modifier,
			&i.DiceType,
			&i.DiceCount,
			&i.Result,
			&i.Total,
			&i.WasOverridden,
			&i.OriginalIntention,
			&i.Status,
			&i.CreatedAt,
			&i.OverriddenBy,
			&i.OverrideReason,
			&i.OverrideTimestamp,
			&i.ManualResult,
			&i.ManuallyResolvedBy,
			&i.ManualResolutionReason,
			&i.RolledAt,
			&i.CharacterName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoll = `-- name: GetRoll :one
SELECT id, post_id, scene_id, character_id, requested_by, intention, modifier, dice_type, dice_count, result, total, was_overridden, original_intention, status, created_at, overridden_by, override_reason, override_timestamp, manual_result, manually_resolved_by, manual_resolution_reason, rolled_at FROM rolls WHERE id = $1
`

func (q *Queries) GetRoll(ctx context.Context, id pgtype.UUID) (Roll, error) {
	row := q.db.QueryRow(ctx, getRoll, id)
	var i Roll
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.SceneID,
		&i.CharacterID,
		&i.RequestedBy,
		&i.Intention,
		&i.Modifier,
		&i.DiceType,
		&i.DiceCount,
		&i.Result,
		&i.Total,
		&i.WasOverridden,
		&i.OriginalIntention,
		&i.Status,
		&i.CreatedAt,
		&i.OverriddenBy,
		&i.OverrideReason,
		&i.OverrideTimestamp,
		&i.ManualResult,
		&i.ManuallyResolvedBy,
		&i.ManualResolutionReason,
		&i.RolledAt,
	)
	return i, err
}

const getRollCountByStatus = `-- name: GetRollCountByStatus :one
SELECT
    COUNT(*) FILTER (WHERE status = 'pending') AS pending,
    COUNT(*) FILTER (WHERE status = 'completed') AS completed,
    COUNT(*) FILTER (WHERE status = 'invalidated') AS invalidated
FROM rolls r
JOIN scenes s ON r.scene_id = s.id
WHERE s.campaign_id = $1
`

type GetRollCountByStatusRow struct {
	Pending     int64 `json:"pending"`
	Completed   int64 `json:"completed"`
	Invalidated int64 `json:"invalidated"`
}

func (q *Queries) GetRollCountByStatus(ctx context.Context, campaignID pgtype.UUID) (GetRollCountByStatusRow, error) {
	row := q.db.QueryRow(ctx, getRollCountByStatus, campaignID)
	var i GetRollCountByStatusRow
	err := row.Scan(&i.Pending, &i.Completed, &i.Invalidated)
	return i, err
}

const getRollWithCharacter = `-- name: GetRollWithCharacter :one
SELECT
    r.id, r.post_id, r.scene_id, r.character_id, r.requested_by, r.intention, r.modifier, r.dice_type, r.dice_count, r.result, r.total, r.was_overridden, r.original_intention, r.status, r.created_at, r.overridden_by, r.override_reason, r.override_timestamp, r.manual_result, r.manually_resolved_by, r.manual_resolution_reason, r.rolled_at,
    c.display_name AS character_name
FROM rolls r
LEFT JOIN characters c ON r.character_id = c.id
WHERE r.id = $1
`

type GetRollWithCharacterRow struct {
	ID                     pgtype.UUID        `json:"id"`
	PostID                 pgtype.UUID        `json:"post_id"`
	SceneID                pgtype.UUID        `json:"scene_id"`
	CharacterID            pgtype.UUID        `json:"character_id"`
	RequestedBy            pgtype.UUID        `json:"requested_by"`
	Intention              string             `json:"intention"`
	Modifier               int32              `json:"modifier"`
	DiceType               string             `json:"dice_type"`
	DiceCount              int32              `json:"dice_count"`
	Result                 []int32            `json:"result"`
	Total                  pgtype.Int4        `json:"total"`
	WasOverridden          bool               `json:"was_overridden"`
	OriginalIntention      pgtype.Text        `json:"original_intention"`
	Status                 RollStatus         `json:"status"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	OverriddenBy           pgtype.UUID        `json:"overridden_by"`
	OverrideReason         pgtype.Text        `json:"override_reason"`
	OverrideTimestamp      pgtype.Timestamptz `json:"override_timestamp"`
	ManualResult           pgtype.Int4        `json:"manual_result"`
	ManuallyResolvedBy     pgtype.UUID        `json:"manually_resolved_by"`
	ManualResolutionReason pgtype.Text        `json:"manual_resolution_reason"`
	RolledAt               pgtype.Timestamptz `json:"rolled_at"`
	CharacterName          pgtype.Text        `json:"character_name"`
}

func (q *Queries) GetRollWithCharacter(ctx context.Context, id pgtype.UUID) (GetRollWithCharacterRow, error) {
	row := q.db.QueryRow(ctx, getRollWithCharacter, id)
	var i GetRollWithCharacterRow
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.SceneID,
		&i.CharacterID,
		&i.RequestedBy,
		&i.Intention,
		&i.Modifier,
		&i.DiceType,
		&i.DiceCount,
		&i.Result,
		&i.Total,
		&i.WasOverridden,
		&i.OriginalIntention,
		&i.Status,
		&i.CreatedAt,
		&i.OverriddenBy,
		&i.OverrideReason,
		&i.OverrideTimestamp,
		&i.ManualResult,
		&i.ManuallyResolvedBy,
		&i.ManualResolutionReason,
		&i.RolledAt,
		&i.CharacterName,
	)
	return i, err
}

const getRollsByPost = `-- name: GetRollsByPost :many
SELECT id, post_id, scene_id, character_id, requested_by, intention, modifier, dice_type, dice_count, result, total, was_overridden, original_intention, status, created_at, overridden_by, override_reason, override_timestamp, manual_result, manually_resolved_by, manual_resolution_reason, rolled_at FROM rolls
WHERE post_id = $1
ORDER BY created_at ASC
`

func (q *Queries) GetRollsByPost(ctx context.Context, postID pgtype.UUID) ([]Roll, error) {
	rows, err := q.db.Query(ctx, getRollsByPost, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Roll
	for rows.Next() {
		var i Roll
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.SceneID,
			&i.CharacterID,
			&i.RequestedBy,
			&i.Intention,
			&i.Modifier,
			&i.DiceType,
			&i.DiceCount,
			&i.Result,
			&i.Total,
			&i.WasOverridden,
			&i.OriginalIntention,
			&i.Status,
			&i.CreatedAt,
			&i.OverriddenBy,
			&i.OverrideReason,
			&i.OverrideTimestamp,
			&i.ManualResult,
			&i.ManuallyResolvedBy,
			&i.ManualResolutionReason,
			&i.RolledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRollsByPostWithCharacter = `-- name: GetRollsByPostWithCharacter :many
SELECT
    r.id, r.post_id, r.scene_id, r.character_id, r.requested_by, r.intention, r.modifier, r.dice_type, r.dice_count, r.result, r.total, r.was_overridden, r.original_intention, r.status, r.created_at, r.overridden_by, r.override_reason, r.override_timestamp, r.manual_result, r.manually_resolved_by, r.manual_resolution_reason, r.rolled_at,
    c.display_name AS character_name
FROM rolls r
LEFT JOIN characters c ON r.character_id = c.id
WHERE r.post_id = $1
ORDER BY r.created_at ASC
`

type GetRollsByPostWithCharacterRow struct {
	ID                     pgtype.UUID        `json:"id"`
	PostID                 pgtype.UUID        `json:"post_id"`
	SceneID                pgtype.UUID        `json:"scene_id"`
	CharacterID            pgtype.UUID        `json:"character_id"`
	RequestedBy            pgtype.UUID        `json:"requested_by"`
	Intention              string             `json:"intention"`
	Modifier               int32              `json:"modifier"`
	DiceType               string             `json:"dice_type"`
	DiceCount              int32              `json:"dice_count"`
	Result                 []int32            `json:"result"`
	Total                  pgtype.Int4        `json:"total"`
	WasOverridden          bool               `json:"was_overridden"`
	OriginalIntention      pgtype.Text        `json:"original_intention"`
	Status                 RollStatus         `json:"status"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	OverriddenBy           pgtype.UUID        `json:"overridden_by"`
	OverrideReason         pgtype.Text        `json:"override_reason"`
	OverrideTimestamp      pgtype.Timestamptz `json:"override_timestamp"`
	ManualResult           pgtype.Int4        `json:"manual_result"`
	ManuallyResolvedBy     pgtype.UUID        `json:"manually_resolved_by"`
	ManualResolutionReason pgtype.Text        `json:"manual_resolution_reason"`
	RolledAt               pgtype.Timestamptz `json:"rolled_at"`
	CharacterName          pgtype.Text        `json:"character_name"`
}

func (q *Queries) GetRollsByPostWithCharacter(ctx context.Context, postID pgtype.UUID) ([]GetRollsByPostWithCharacterRow, error) {
	rows, err := q.db.Query(ctx, getRollsByPostWithCharacter, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRollsByPostWithCharacterRow
	for rows.Next() {
		var i GetRollsByPostWithCharacterRow
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.SceneID,
			&i.CharacterID,
			&i.RequestedBy,
			&i.Intention,
			&i.Modifier,
			&i.DiceType,
			&i.DiceCount,
			&i.Result,
			&i.Total,
			&i.WasOverridden,
			&i.OriginalIntention,
			&i.Status,
			&i.CreatedAt,
			&i.OverriddenBy,
			&i.OverrideReason,
			&i.OverrideTimestamp,
			&i.ManualResult,
			&i.ManuallyResolvedBy,
			&i.ManualResolutionReason,
			&i.RolledAt,
			&i.CharacterName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRollsInSceneByStatus = `-- name: GetRollsInSceneByStatus :many
SELECT
    r.id, r.post_id, r.scene_id, r.character_id, r.requested_by, r.intention, r.modifier, r.dice_type, r.dice_count, r.result, r.total, r.was_overridden, r.original_intention, r.status, r.created_at, r.overridden_by, r.override_reason, r.override_timestamp, r.manual_result, r.manually_resolved_by, r.manual_resolution_reason, r.rolled_at,
    c.display_name AS character_name
FROM rolls r
LEFT JOIN characters c ON r.character_id = c.id
WHERE r.scene_id = $1
  AND r.status = $2
ORDER BY r.created_at DESC
`

type GetRollsInSceneByStatusParams struct {
	SceneID pgtype.UUID `json:"scene_id"`
	Status  RollStatus  `json:"status"`
}

type GetRollsInSceneByStatusRow struct {
	ID                     pgtype.UUID        `json:"id"`
	PostID                 pgtype.UUID        `json:"post_id"`
	SceneID                pgtype.UUID        `json:"scene_id"`
	CharacterID            pgtype.UUID        `json:"character_id"`
	RequestedBy            pgtype.UUID        `json:"requested_by"`
	Intention              string             `json:"intention"`
	Modifier               int32              `json:"modifier"`
	DiceType               string             `json:"dice_type"`
	DiceCount              int32              `json:"dice_count"`
	Result                 []int32            `json:"result"`
	Total                  pgtype.Int4        `json:"total"`
	WasOverridden          bool               `json:"was_overridden"`
	OriginalIntention      pgtype.Text        `json:"original_intention"`
	Status                 RollStatus         `json:"status"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	OverriddenBy           pgtype.UUID        `json:"overridden_by"`
	OverrideReason         pgtype.Text        `json:"override_reason"`
	OverrideTimestamp      pgtype.Timestamptz `json:"override_timestamp"`
	ManualResult           pgtype.Int4        `json:"manual_result"`
	ManuallyResolvedBy     pgtype.UUID        `json:"manually_resolved_by"`
	ManualResolutionReason pgtype.Text        `json:"manual_resolution_reason"`
	RolledAt               pgtype.Timestamptz `json:"rolled_at"`
	CharacterName          pgtype.Text        `json:"character_name"`
}

func (q *Queries) GetRollsInSceneByStatus(ctx context.Context, arg GetRollsInSceneByStatusParams) ([]GetRollsInSceneByStatusRow, error) {
	rows, err := q.db.Query(ctx, getRollsInSceneByStatus, arg.SceneID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRollsInSceneByStatusRow
	for rows.Next() {
		var i GetRollsInSceneByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.SceneID,
			&i.CharacterID,
			&i.RequestedBy,
			&i.Intention,
			&i.Modifier,
			&i.DiceType,
			&i.DiceCount,
			&i.Result,
			&i.Total,
			&i.WasOverridden,
			&i.OriginalIntention,
			&i.Status,
			&i.CreatedAt,
			&i.OverriddenBy,
			&i.OverrideReason,
			&i.OverrideTimestamp,
			&i.ManualResult,
			&i.ManuallyResolvedBy,
			&i.ManualResolutionReason,
			&i.RolledAt,
			&i.CharacterName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSceneIDForRoll = `-- name: GetSceneIDForRoll :one
SELECT scene_id FROM rolls WHERE id = $1
`

func (q *Queries) GetSceneIDForRoll(ctx context.Context, id pgtype.UUID) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getSceneIDForRoll, id)
	var scene_id pgtype.UUID
	err := row.Scan(&scene_id)
	return scene_id, err
}

const getUnresolvedRollsInCampaign = `-- name: GetUnresolvedRollsInCampaign :many
SELECT
    r.id, r.post_id, r.scene_id, r.character_id, r.requested_by, r.intention, r.modifier, r.dice_type, r.dice_count, r.result, r.total, r.was_overridden, r.original_intention, r.status, r.created_at, r.overridden_by, r.override_reason, r.override_timestamp, r.manual_result, r.manually_resolved_by, r.manual_resolution_reason, r.rolled_at,
    c.display_name AS character_name,
    s.title AS scene_title,
    p.blocks AS post_content
FROM rolls r
JOIN characters c ON c.id = r.character_id
JOIN scenes s ON s.id = r.scene_id
LEFT JOIN posts p ON p.id = r.post_id
WHERE s.campaign_id = $1
  AND r.status = 'pending'
ORDER BY r.created_at ASC
`

type GetUnresolvedRollsInCampaignRow struct {
	ID                     pgtype.UUID        `json:"id"`
	PostID                 pgtype.UUID        `json:"post_id"`
	SceneID                pgtype.UUID        `json:"scene_id"`
	CharacterID            pgtype.UUID        `json:"character_id"`
	RequestedBy            pgtype.UUID        `json:"requested_by"`
	Intention              string             `json:"intention"`
	Modifier               int32              `json:"modifier"`
	DiceType               string             `json:"dice_type"`
	DiceCount              int32              `json:"dice_count"`
	Result                 []int32            `json:"result"`
	Total                  pgtype.Int4        `json:"total"`
	WasOverridden          bool               `json:"was_overridden"`
	OriginalIntention      pgtype.Text        `json:"original_intention"`
	Status                 RollStatus         `json:"status"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	OverriddenBy           pgtype.UUID        `json:"overridden_by"`
	OverrideReason         pgtype.Text        `json:"override_reason"`
	OverrideTimestamp      pgtype.Timestamptz `json:"override_timestamp"`
	ManualResult           pgtype.Int4        `json:"manual_result"`
	ManuallyResolvedBy     pgtype.UUID        `json:"manually_resolved_by"`
	ManualResolutionReason pgtype.Text        `json:"manual_resolution_reason"`
	RolledAt               pgtype.Timestamptz `json:"rolled_at"`
	CharacterName          string             `json:"character_name"`
	SceneTitle             string             `json:"scene_title"`
	PostContent            []byte             `json:"post_content"`
}

func (q *Queries) GetUnresolvedRollsInCampaign(ctx context.Context, campaignID pgtype.UUID) ([]GetUnresolvedRollsInCampaignRow, error) {
	rows, err := q.db.Query(ctx, getUnresolvedRollsInCampaign, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnresolvedRollsInCampaignRow
	for rows.Next() {
		var i GetUnresolvedRollsInCampaignRow
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.SceneID,
			&i.CharacterID,
			&i.RequestedBy,
			&i.Intention,
			&i.Modifier,
			&i.DiceType,
			&i.DiceCount,
			&i.Result,
			&i.Total,
			&i.WasOverridden,
			&i.OriginalIntention,
			&i.Status,
			&i.CreatedAt,
			&i.OverriddenBy,
			&i.OverrideReason,
			&i.OverrideTimestamp,
			&i.ManualResult,
			&i.ManuallyResolvedBy,
			&i.ManualResolutionReason,
			&i.RolledAt,
			&i.CharacterName,
			&i.SceneTitle,
			&i.PostContent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const invalidateRoll = `-- name: InvalidateRoll :one
UPDATE rolls
SET status = 'invalidated'
WHERE id = $1
RETURNING id, post_id, scene_id, character_id, requested_by, intention, modifier, dice_type, dice_count, result, total, was_overridden, original_intention, status, created_at, overridden_by, override_reason, override_timestamp, manual_result, manually_resolved_by, manual_resolution_reason, rolled_at
`

func (q *Queries) InvalidateRoll(ctx context.Context, id pgtype.UUID) (Roll, error) {
	row := q.db.QueryRow(ctx, invalidateRoll, id)
	var i Roll
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.SceneID,
		&i.CharacterID,
		&i.RequestedBy,
		&i.Intention,
		&i.Modifier,
		&i.DiceType,
		&i.DiceCount,
		&i.Result,
		&i.Total,
		&i.WasOverridden,
		&i.OriginalIntention,
		&i.Status,
		&i.CreatedAt,
		&i.OverriddenBy,
		&i.OverrideReason,
		&i.OverrideTimestamp,
		&i.ManualResult,
		&i.ManuallyResolvedBy,
		&i.ManualResolutionReason,
		&i.RolledAt,
	)
	return i, err
}

const listRollsByScene = `-- name: ListRollsByScene :many
SELECT
    r.id, r.post_id, r.scene_id, r.character_id, r.requested_by, r.intention, r.modifier, r.dice_type, r.dice_count, r.result, r.total, r.was_overridden, r.original_intention, r.status, r.created_at, r.overridden_by, r.override_reason, r.override_timestamp, r.manual_result, r.manually_resolved_by, r.manual_resolution_reason, r.rolled_at,
    c.display_name AS character_name
FROM rolls r
LEFT JOIN characters c ON r.character_id = c.id
WHERE r.scene_id = $1
ORDER BY r.created_at DESC
`

type ListRollsBySceneRow struct {
	ID                     pgtype.UUID        `json:"id"`
	PostID                 pgtype.UUID        `json:"post_id"`
	SceneID                pgtype.UUID        `json:"scene_id"`
	CharacterID            pgtype.UUID        `json:"character_id"`
	RequestedBy            pgtype.UUID        `json:"requested_by"`
	Intention              string             `json:"intention"`
	Modifier               int32              `json:"modifier"`
	DiceType               string             `json:"dice_type"`
	DiceCount              int32              `json:"dice_count"`
	Result                 []int32            `json:"result"`
	Total                  pgtype.Int4        `json:"total"`
	WasOverridden          bool               `json:"was_overridden"`
	OriginalIntention      pgtype.Text        `json:"original_intention"`
	Status                 RollStatus         `json:"status"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	OverriddenBy           pgtype.UUID        `json:"overridden_by"`
	OverrideReason         pgtype.Text        `json:"override_reason"`
	OverrideTimestamp      pgtype.Timestamptz `json:"override_timestamp"`
	ManualResult           pgtype.Int4        `json:"manual_result"`
	ManuallyResolvedBy     pgtype.UUID        `json:"manually_resolved_by"`
	ManualResolutionReason pgtype.Text        `json:"manual_resolution_reason"`
	RolledAt               pgtype.Timestamptz `json:"rolled_at"`
	CharacterName          pgtype.Text        `json:"character_name"`
}

func (q *Queries) ListRollsByScene(ctx context.Context, sceneID pgtype.UUID) ([]ListRollsBySceneRow, error) {
	rows, err := q.db.Query(ctx, listRollsByScene, sceneID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRollsBySceneRow
	for rows.Next() {
		var i ListRollsBySceneRow
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.SceneID,
			&i.CharacterID,
			&i.RequestedBy,
			&i.Intention,
			&i.Modifier,
			&i.DiceType,
			&i.DiceCount,
			&i.Result,
			&i.Total,
			&i.WasOverridden,
			&i.OriginalIntention,
			&i.Status,
			&i.CreatedAt,
			&i.OverriddenBy,
			&i.OverrideReason,
			&i.OverrideTimestamp,
			&i.ManualResult,
			&i.ManuallyResolvedBy,
			&i.ManualResolutionReason,
			&i.RolledAt,
			&i.CharacterName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const manuallyResolveRoll = `-- name: ManuallyResolveRoll :one
UPDATE rolls
SET
    manual_result = $2,
    manually_resolved_by = $3,
    manual_resolution_reason = $4,
    total = $2,
    status = 'completed',
    rolled_at = NOW()
WHERE id = $1
RETURNING id, post_id, scene_id, character_id, requested_by, intention, modifier, dice_type, dice_count, result, total, was_overridden, original_intention, status, created_at, overridden_by, override_reason, override_timestamp, manual_result, manually_resolved_by, manual_resolution_reason, rolled_at
`

type ManuallyResolveRollParams struct {
	ID                     pgtype.UUID `json:"id"`
	ManualResult           pgtype.Int4 `json:"manual_result"`
	ManuallyResolvedBy     pgtype.UUID `json:"manually_resolved_by"`
	ManualResolutionReason pgtype.Text `json:"manual_resolution_reason"`
}

func (q *Queries) ManuallyResolveRoll(ctx context.Context, arg ManuallyResolveRollParams) (Roll, error) {
	row := q.db.QueryRow(ctx, manuallyResolveRoll,
		arg.ID,
		arg.ManualResult,
		arg.ManuallyResolvedBy,
		arg.ManualResolutionReason,
	)
	var i Roll
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.SceneID,
		&i.CharacterID,
		&i.RequestedBy,
		&i.Intention,
		&i.Modifier,
		&i.DiceType,
		&i.DiceCount,
		&i.Result,
		&i.Total,
		&i.WasOverridden,
		&i.OriginalIntention,
		&i.Status,
		&i.CreatedAt,
		&i.OverriddenBy,
		&i.OverrideReason,
		&i.OverrideTimestamp,
		&i.ManualResult,
		&i.ManuallyResolvedBy,
		&i.ManualResolutionReason,
		&i.RolledAt,
	)
	return i, err
}

const overrideRollIntention = `-- name: OverrideRollIntention :one
UPDATE rolls
SET
    original_intention = CASE WHEN original_intention IS NULL THEN intention ELSE original_intention END,
    intention = $2,
    was_overridden = true,
    overridden_by = $3,
    override_reason = $4,
    override_timestamp = NOW()
WHERE id = $1
RETURNING id, post_id, scene_id, character_id, requested_by, intention, modifier, dice_type, dice_count, result, total, was_overridden, original_intention, status, created_at, overridden_by, override_reason, override_timestamp, manual_result, manually_resolved_by, manual_resolution_reason, rolled_at
`

type OverrideRollIntentionParams struct {
	ID             pgtype.UUID `json:"id"`
	Intention      string      `json:"intention"`
	OverriddenBy   pgtype.UUID `json:"overridden_by"`
	OverrideReason pgtype.Text `json:"override_reason"`
}

func (q *Queries) OverrideRollIntention(ctx context.Context, arg OverrideRollIntentionParams) (Roll, error) {
	row := q.db.QueryRow(ctx, overrideRollIntention,
		arg.ID,
		arg.Intention,
		arg.OverriddenBy,
		arg.OverrideReason,
	)
	var i Roll
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.SceneID,
		&i.CharacterID,
		&i.RequestedBy,
		&i.Intention,
		&i.Modifier,
		&i.DiceType,
		&i.DiceCount,
		&i.Result,
		&i.Total,
		&i.WasOverridden,
		&i.OriginalIntention,
		&i.Status,
		&i.CreatedAt,
		&i.OverriddenBy,
		&i.OverrideReason,
		&i.OverrideTimestamp,
		&i.ManualResult,
		&i.ManuallyResolvedBy,
		&i.ManualResolutionReason,
		&i.RolledAt,
	)
	return i, err
}
