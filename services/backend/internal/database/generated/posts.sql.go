// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: posts.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countScenePosts = `-- name: CountScenePosts :one
SELECT COUNT(*) FROM posts
WHERE scene_id = $1 AND is_draft = false
`

func (q *Queries) CountScenePosts(ctx context.Context, sceneID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countScenePosts, sceneID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO posts (
    scene_id,
    character_id,
    user_id,
    blocks,
    ooc_text,
    witnesses,
    is_hidden,
    is_draft,
    intention,
    modifier
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, scene_id, character_id, user_id, blocks, ooc_text, witnesses, is_hidden, is_draft, is_locked, locked_at, edited_by_gm, intention, modifier, created_at, updated_at
`

type CreatePostParams struct {
	SceneID     pgtype.UUID   `json:"scene_id"`
	CharacterID pgtype.UUID   `json:"character_id"`
	UserID      pgtype.UUID   `json:"user_id"`
	Blocks      []byte        `json:"blocks"`
	OocText     pgtype.Text   `json:"ooc_text"`
	Witnesses   []pgtype.UUID `json:"witnesses"`
	IsHidden    bool          `json:"is_hidden"`
	IsDraft     bool          `json:"is_draft"`
	Intention   pgtype.Text   `json:"intention"`
	Modifier    pgtype.Int4   `json:"modifier"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, createPost,
		arg.SceneID,
		arg.CharacterID,
		arg.UserID,
		arg.Blocks,
		arg.OocText,
		arg.Witnesses,
		arg.IsHidden,
		arg.IsDraft,
		arg.Intention,
		arg.Modifier,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.SceneID,
		&i.CharacterID,
		&i.UserID,
		&i.Blocks,
		&i.OocText,
		&i.Witnesses,
		&i.IsHidden,
		&i.IsDraft,
		&i.IsLocked,
		&i.LockedAt,
		&i.EditedByGm,
		&i.Intention,
		&i.Modifier,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :exec
DELETE FROM posts WHERE id = $1
`

func (q *Queries) DeletePost(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePost, id)
	return err
}

const editPostWitnesses = `-- name: EditPostWitnesses :one
UPDATE posts
SET
    witnesses = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, scene_id, character_id, user_id, blocks, ooc_text, witnesses, is_hidden, is_draft, is_locked, locked_at, edited_by_gm, intention, modifier, created_at, updated_at
`

type EditPostWitnessesParams struct {
	ID        pgtype.UUID   `json:"id"`
	Witnesses []pgtype.UUID `json:"witnesses"`
}

// GM-only: Update witnesses on a post without changing hidden status
func (q *Queries) EditPostWitnesses(ctx context.Context, arg EditPostWitnessesParams) (Post, error) {
	row := q.db.QueryRow(ctx, editPostWitnesses, arg.ID, arg.Witnesses)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.SceneID,
		&i.CharacterID,
		&i.UserID,
		&i.Blocks,
		&i.OocText,
		&i.Witnesses,
		&i.IsHidden,
		&i.IsDraft,
		&i.IsLocked,
		&i.LockedAt,
		&i.EditedByGm,
		&i.Intention,
		&i.Modifier,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCharacterPostCountInScene = `-- name: GetCharacterPostCountInScene :one
SELECT COUNT(*) FROM posts
WHERE scene_id = $1 AND character_id = $2 AND is_draft = false
`

type GetCharacterPostCountInSceneParams struct {
	SceneID     pgtype.UUID `json:"scene_id"`
	CharacterID pgtype.UUID `json:"character_id"`
}

func (q *Queries) GetCharacterPostCountInScene(ctx context.Context, arg GetCharacterPostCountInSceneParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCharacterPostCountInScene, arg.SceneID, arg.CharacterID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLastScenePost = `-- name: GetLastScenePost :one
SELECT id, scene_id, character_id, user_id, blocks, ooc_text, witnesses, is_hidden, is_draft, is_locked, locked_at, edited_by_gm, intention, modifier, created_at, updated_at FROM posts
WHERE scene_id = $1 AND is_draft = false
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLastScenePost(ctx context.Context, sceneID pgtype.UUID) (Post, error) {
	row := q.db.QueryRow(ctx, getLastScenePost, sceneID)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.SceneID,
		&i.CharacterID,
		&i.UserID,
		&i.Blocks,
		&i.OocText,
		&i.Witnesses,
		&i.IsHidden,
		&i.IsDraft,
		&i.IsLocked,
		&i.LockedAt,
		&i.EditedByGm,
		&i.Intention,
		&i.Modifier,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPost = `-- name: GetPost :one
SELECT id, scene_id, character_id, user_id, blocks, ooc_text, witnesses, is_hidden, is_draft, is_locked, locked_at, edited_by_gm, intention, modifier, created_at, updated_at FROM posts WHERE id = $1
`

func (q *Queries) GetPost(ctx context.Context, id pgtype.UUID) (Post, error) {
	row := q.db.QueryRow(ctx, getPost, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.SceneID,
		&i.CharacterID,
		&i.UserID,
		&i.Blocks,
		&i.OocText,
		&i.Witnesses,
		&i.IsHidden,
		&i.IsDraft,
		&i.IsLocked,
		&i.LockedAt,
		&i.EditedByGm,
		&i.Intention,
		&i.Modifier,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPostCountForCharacterInScene = `-- name: GetPostCountForCharacterInScene :one
SELECT COUNT(*)
FROM posts
WHERE scene_id = $1
  AND $2::uuid = ANY(witnesses)
  AND is_draft = false
`

type GetPostCountForCharacterInSceneParams struct {
	SceneID pgtype.UUID `json:"scene_id"`
	Column2 pgtype.UUID `json:"column_2"`
}

// Count posts visible to a specific character in a scene
func (q *Queries) GetPostCountForCharacterInScene(ctx context.Context, arg GetPostCountForCharacterInSceneParams) (int64, error) {
	row := q.db.QueryRow(ctx, getPostCountForCharacterInScene, arg.SceneID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPostWithCharacter = `-- name: GetPostWithCharacter :one
SELECT
    p.id, p.scene_id, p.character_id, p.user_id, p.blocks, p.ooc_text, p.witnesses, p.is_hidden, p.is_draft, p.is_locked, p.locked_at, p.edited_by_gm, p.intention, p.modifier, p.created_at, p.updated_at,
    c.display_name AS character_name,
    c.avatar_url AS character_avatar,
    c.character_type
FROM posts p
LEFT JOIN characters c ON p.character_id = c.id
WHERE p.id = $1
`

type GetPostWithCharacterRow struct {
	ID              pgtype.UUID        `json:"id"`
	SceneID         pgtype.UUID        `json:"scene_id"`
	CharacterID     pgtype.UUID        `json:"character_id"`
	UserID          pgtype.UUID        `json:"user_id"`
	Blocks          []byte             `json:"blocks"`
	OocText         pgtype.Text        `json:"ooc_text"`
	Witnesses       []pgtype.UUID      `json:"witnesses"`
	IsHidden        bool               `json:"is_hidden"`
	IsDraft         bool               `json:"is_draft"`
	IsLocked        bool               `json:"is_locked"`
	LockedAt        pgtype.Timestamptz `json:"locked_at"`
	EditedByGm      bool               `json:"edited_by_gm"`
	Intention       pgtype.Text        `json:"intention"`
	Modifier        pgtype.Int4        `json:"modifier"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	CharacterName   pgtype.Text        `json:"character_name"`
	CharacterAvatar pgtype.Text        `json:"character_avatar"`
	CharacterType   NullCharacterType  `json:"character_type"`
}

func (q *Queries) GetPostWithCharacter(ctx context.Context, id pgtype.UUID) (GetPostWithCharacterRow, error) {
	row := q.db.QueryRow(ctx, getPostWithCharacter, id)
	var i GetPostWithCharacterRow
	err := row.Scan(
		&i.ID,
		&i.SceneID,
		&i.CharacterID,
		&i.UserID,
		&i.Blocks,
		&i.OocText,
		&i.Witnesses,
		&i.IsHidden,
		&i.IsDraft,
		&i.IsLocked,
		&i.LockedAt,
		&i.EditedByGm,
		&i.Intention,
		&i.Modifier,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CharacterName,
		&i.CharacterAvatar,
		&i.CharacterType,
	)
	return i, err
}

const getPreviousPost = `-- name: GetPreviousPost :one
SELECT id, scene_id, character_id, user_id, blocks, ooc_text, witnesses, is_hidden, is_draft, is_locked, locked_at, edited_by_gm, intention, modifier, created_at, updated_at FROM posts
WHERE scene_id = $1
    AND is_draft = false
    AND created_at < $2
ORDER BY created_at DESC
LIMIT 1
`

type GetPreviousPostParams struct {
	SceneID   pgtype.UUID        `json:"scene_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetPreviousPost(ctx context.Context, arg GetPreviousPostParams) (Post, error) {
	row := q.db.QueryRow(ctx, getPreviousPost, arg.SceneID, arg.CreatedAt)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.SceneID,
		&i.CharacterID,
		&i.UserID,
		&i.Blocks,
		&i.OocText,
		&i.Witnesses,
		&i.IsHidden,
		&i.IsDraft,
		&i.IsLocked,
		&i.LockedAt,
		&i.EditedByGm,
		&i.Intention,
		&i.Modifier,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getScenePostCount = `-- name: GetScenePostCount :one
SELECT COUNT(*) FROM posts
WHERE scene_id = $1 AND is_draft = false
`

func (q *Queries) GetScenePostCount(ctx context.Context, sceneID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getScenePostCount, sceneID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserDraftPost = `-- name: GetUserDraftPost :one
SELECT id, scene_id, character_id, user_id, blocks, ooc_text, witnesses, is_hidden, is_draft, is_locked, locked_at, edited_by_gm, intention, modifier, created_at, updated_at FROM posts
WHERE scene_id = $1 AND character_id = $2 AND user_id = $3 AND is_draft = true
LIMIT 1
`

type GetUserDraftPostParams struct {
	SceneID     pgtype.UUID `json:"scene_id"`
	CharacterID pgtype.UUID `json:"character_id"`
	UserID      pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetUserDraftPost(ctx context.Context, arg GetUserDraftPostParams) (Post, error) {
	row := q.db.QueryRow(ctx, getUserDraftPost, arg.SceneID, arg.CharacterID, arg.UserID)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.SceneID,
		&i.CharacterID,
		&i.UserID,
		&i.Blocks,
		&i.OocText,
		&i.Witnesses,
		&i.IsHidden,
		&i.IsDraft,
		&i.IsLocked,
		&i.LockedAt,
		&i.EditedByGm,
		&i.Intention,
		&i.Modifier,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listHiddenPostsInScene = `-- name: ListHiddenPostsInScene :many
SELECT
    p.id, p.scene_id, p.character_id, p.user_id, p.blocks, p.ooc_text, p.witnesses, p.is_hidden, p.is_draft, p.is_locked, p.locked_at, p.edited_by_gm, p.intention, p.modifier, p.created_at, p.updated_at,
    c.display_name AS character_name,
    c.avatar_url AS character_avatar,
    c.character_type
FROM posts p
LEFT JOIN characters c ON p.character_id = c.id
WHERE p.scene_id = $1 AND p.is_hidden = true AND p.is_draft = false
ORDER BY p.created_at ASC
`

type ListHiddenPostsInSceneRow struct {
	ID              pgtype.UUID        `json:"id"`
	SceneID         pgtype.UUID        `json:"scene_id"`
	CharacterID     pgtype.UUID        `json:"character_id"`
	UserID          pgtype.UUID        `json:"user_id"`
	Blocks          []byte             `json:"blocks"`
	OocText         pgtype.Text        `json:"ooc_text"`
	Witnesses       []pgtype.UUID      `json:"witnesses"`
	IsHidden        bool               `json:"is_hidden"`
	IsDraft         bool               `json:"is_draft"`
	IsLocked        bool               `json:"is_locked"`
	LockedAt        pgtype.Timestamptz `json:"locked_at"`
	EditedByGm      bool               `json:"edited_by_gm"`
	Intention       pgtype.Text        `json:"intention"`
	Modifier        pgtype.Int4        `json:"modifier"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	CharacterName   pgtype.Text        `json:"character_name"`
	CharacterAvatar pgtype.Text        `json:"character_avatar"`
	CharacterType   NullCharacterType  `json:"character_type"`
}

func (q *Queries) ListHiddenPostsInScene(ctx context.Context, sceneID pgtype.UUID) ([]ListHiddenPostsInSceneRow, error) {
	rows, err := q.db.Query(ctx, listHiddenPostsInScene, sceneID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListHiddenPostsInSceneRow
	for rows.Next() {
		var i ListHiddenPostsInSceneRow
		if err := rows.Scan(
			&i.ID,
			&i.SceneID,
			&i.CharacterID,
			&i.UserID,
			&i.Blocks,
			&i.OocText,
			&i.Witnesses,
			&i.IsHidden,
			&i.IsDraft,
			&i.IsLocked,
			&i.LockedAt,
			&i.EditedByGm,
			&i.Intention,
			&i.Modifier,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CharacterName,
			&i.CharacterAvatar,
			&i.CharacterType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScenePosts = `-- name: ListScenePosts :many
SELECT
    p.id, p.scene_id, p.character_id, p.user_id, p.blocks, p.ooc_text, p.witnesses, p.is_hidden, p.is_draft, p.is_locked, p.locked_at, p.edited_by_gm, p.intention, p.modifier, p.created_at, p.updated_at,
    c.display_name AS character_name,
    c.avatar_url AS character_avatar,
    c.character_type
FROM posts p
LEFT JOIN characters c ON p.character_id = c.id
WHERE p.scene_id = $1 AND p.is_draft = false
ORDER BY p.created_at ASC
`

type ListScenePostsRow struct {
	ID              pgtype.UUID        `json:"id"`
	SceneID         pgtype.UUID        `json:"scene_id"`
	CharacterID     pgtype.UUID        `json:"character_id"`
	UserID          pgtype.UUID        `json:"user_id"`
	Blocks          []byte             `json:"blocks"`
	OocText         pgtype.Text        `json:"ooc_text"`
	Witnesses       []pgtype.UUID      `json:"witnesses"`
	IsHidden        bool               `json:"is_hidden"`
	IsDraft         bool               `json:"is_draft"`
	IsLocked        bool               `json:"is_locked"`
	LockedAt        pgtype.Timestamptz `json:"locked_at"`
	EditedByGm      bool               `json:"edited_by_gm"`
	Intention       pgtype.Text        `json:"intention"`
	Modifier        pgtype.Int4        `json:"modifier"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	CharacterName   pgtype.Text        `json:"character_name"`
	CharacterAvatar pgtype.Text        `json:"character_avatar"`
	CharacterType   NullCharacterType  `json:"character_type"`
}

func (q *Queries) ListScenePosts(ctx context.Context, sceneID pgtype.UUID) ([]ListScenePostsRow, error) {
	rows, err := q.db.Query(ctx, listScenePosts, sceneID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListScenePostsRow
	for rows.Next() {
		var i ListScenePostsRow
		if err := rows.Scan(
			&i.ID,
			&i.SceneID,
			&i.CharacterID,
			&i.UserID,
			&i.Blocks,
			&i.OocText,
			&i.Witnesses,
			&i.IsHidden,
			&i.IsDraft,
			&i.IsLocked,
			&i.LockedAt,
			&i.EditedByGm,
			&i.Intention,
			&i.Modifier,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CharacterName,
			&i.CharacterAvatar,
			&i.CharacterType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScenePostsForCharacter = `-- name: ListScenePostsForCharacter :many
SELECT
    p.id, p.scene_id, p.character_id, p.user_id, p.blocks, p.ooc_text, p.witnesses, p.is_hidden, p.is_draft, p.is_locked, p.locked_at, p.edited_by_gm, p.intention, p.modifier, p.created_at, p.updated_at,
    c.display_name AS character_name,
    c.avatar_url AS character_avatar,
    c.character_type
FROM posts p
LEFT JOIN characters c ON p.character_id = c.id
WHERE p.scene_id = $1
    AND p.is_draft = false
    AND ($2::uuid = ANY(p.witnesses) OR $3 = true)
ORDER BY p.created_at ASC
`

type ListScenePostsForCharacterParams struct {
	SceneID pgtype.UUID `json:"scene_id"`
	Column2 pgtype.UUID `json:"column_2"`
	Column3 interface{} `json:"column_3"`
}

type ListScenePostsForCharacterRow struct {
	ID              pgtype.UUID        `json:"id"`
	SceneID         pgtype.UUID        `json:"scene_id"`
	CharacterID     pgtype.UUID        `json:"character_id"`
	UserID          pgtype.UUID        `json:"user_id"`
	Blocks          []byte             `json:"blocks"`
	OocText         pgtype.Text        `json:"ooc_text"`
	Witnesses       []pgtype.UUID      `json:"witnesses"`
	IsHidden        bool               `json:"is_hidden"`
	IsDraft         bool               `json:"is_draft"`
	IsLocked        bool               `json:"is_locked"`
	LockedAt        pgtype.Timestamptz `json:"locked_at"`
	EditedByGm      bool               `json:"edited_by_gm"`
	Intention       pgtype.Text        `json:"intention"`
	Modifier        pgtype.Int4        `json:"modifier"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	CharacterName   pgtype.Text        `json:"character_name"`
	CharacterAvatar pgtype.Text        `json:"character_avatar"`
	CharacterType   NullCharacterType  `json:"character_type"`
}

func (q *Queries) ListScenePostsForCharacter(ctx context.Context, arg ListScenePostsForCharacterParams) ([]ListScenePostsForCharacterRow, error) {
	rows, err := q.db.Query(ctx, listScenePostsForCharacter, arg.SceneID, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListScenePostsForCharacterRow
	for rows.Next() {
		var i ListScenePostsForCharacterRow
		if err := rows.Scan(
			&i.ID,
			&i.SceneID,
			&i.CharacterID,
			&i.UserID,
			&i.Blocks,
			&i.OocText,
			&i.Witnesses,
			&i.IsHidden,
			&i.IsDraft,
			&i.IsLocked,
			&i.LockedAt,
			&i.EditedByGm,
			&i.Intention,
			&i.Modifier,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CharacterName,
			&i.CharacterAvatar,
			&i.CharacterType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScenePostsPaginated = `-- name: ListScenePostsPaginated :many
SELECT
    p.id, p.scene_id, p.character_id, p.user_id, p.blocks, p.ooc_text, p.witnesses, p.is_hidden, p.is_draft, p.is_locked, p.locked_at, p.edited_by_gm, p.intention, p.modifier, p.created_at, p.updated_at,
    c.display_name AS character_name,
    c.avatar_url AS character_avatar,
    c.character_type
FROM posts p
LEFT JOIN characters c ON p.character_id = c.id
WHERE p.scene_id = $1
    AND p.is_draft = false
    AND ($2::uuid = ANY(p.witnesses) OR $3 = true)
    AND ($4::timestamptz IS NULL OR p.created_at > $4)
ORDER BY p.created_at ASC
LIMIT $5
`

type ListScenePostsPaginatedParams struct {
	SceneID pgtype.UUID        `json:"scene_id"`
	Column2 pgtype.UUID        `json:"column_2"`
	Column3 interface{}        `json:"column_3"`
	Column4 pgtype.Timestamptz `json:"column_4"`
	Limit   int32              `json:"limit"`
}

type ListScenePostsPaginatedRow struct {
	ID              pgtype.UUID        `json:"id"`
	SceneID         pgtype.UUID        `json:"scene_id"`
	CharacterID     pgtype.UUID        `json:"character_id"`
	UserID          pgtype.UUID        `json:"user_id"`
	Blocks          []byte             `json:"blocks"`
	OocText         pgtype.Text        `json:"ooc_text"`
	Witnesses       []pgtype.UUID      `json:"witnesses"`
	IsHidden        bool               `json:"is_hidden"`
	IsDraft         bool               `json:"is_draft"`
	IsLocked        bool               `json:"is_locked"`
	LockedAt        pgtype.Timestamptz `json:"locked_at"`
	EditedByGm      bool               `json:"edited_by_gm"`
	Intention       pgtype.Text        `json:"intention"`
	Modifier        pgtype.Int4        `json:"modifier"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	CharacterName   pgtype.Text        `json:"character_name"`
	CharacterAvatar pgtype.Text        `json:"character_avatar"`
	CharacterType   NullCharacterType  `json:"character_type"`
}

// Cursor-based pagination for posts
func (q *Queries) ListScenePostsPaginated(ctx context.Context, arg ListScenePostsPaginatedParams) ([]ListScenePostsPaginatedRow, error) {
	rows, err := q.db.Query(ctx, listScenePostsPaginated,
		arg.SceneID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListScenePostsPaginatedRow
	for rows.Next() {
		var i ListScenePostsPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.SceneID,
			&i.CharacterID,
			&i.UserID,
			&i.Blocks,
			&i.OocText,
			&i.Witnesses,
			&i.IsHidden,
			&i.IsDraft,
			&i.IsLocked,
			&i.LockedAt,
			&i.EditedByGm,
			&i.Intention,
			&i.Modifier,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CharacterName,
			&i.CharacterAvatar,
			&i.CharacterType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockPost = `-- name: LockPost :exec
UPDATE posts
SET
    is_locked = true,
    locked_at = NOW()
WHERE id = $1
`

func (q *Queries) LockPost(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, lockPost, id)
	return err
}

const submitPost = `-- name: SubmitPost :one
UPDATE posts
SET
    is_draft = false,
    witnesses = $2,
    is_hidden = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, scene_id, character_id, user_id, blocks, ooc_text, witnesses, is_hidden, is_draft, is_locked, locked_at, edited_by_gm, intention, modifier, created_at, updated_at
`

type SubmitPostParams struct {
	ID        pgtype.UUID   `json:"id"`
	Witnesses []pgtype.UUID `json:"witnesses"`
	IsHidden  bool          `json:"is_hidden"`
}

func (q *Queries) SubmitPost(ctx context.Context, arg SubmitPostParams) (Post, error) {
	row := q.db.QueryRow(ctx, submitPost, arg.ID, arg.Witnesses, arg.IsHidden)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.SceneID,
		&i.CharacterID,
		&i.UserID,
		&i.Blocks,
		&i.OocText,
		&i.Witnesses,
		&i.IsHidden,
		&i.IsDraft,
		&i.IsLocked,
		&i.LockedAt,
		&i.EditedByGm,
		&i.Intention,
		&i.Modifier,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const unhidePostWithCustomWitnesses = `-- name: UnhidePostWithCustomWitnesses :one
UPDATE posts
SET
    witnesses = $2,
    is_hidden = false,
    updated_at = NOW()
WHERE id = $1 AND is_hidden = true
RETURNING id, scene_id, character_id, user_id, blocks, ooc_text, witnesses, is_hidden, is_draft, is_locked, locked_at, edited_by_gm, intention, modifier, created_at, updated_at
`

type UnhidePostWithCustomWitnessesParams struct {
	ID        pgtype.UUID   `json:"id"`
	Witnesses []pgtype.UUID `json:"witnesses"`
}

// GM can unhide a post and set specific witnesses
func (q *Queries) UnhidePostWithCustomWitnesses(ctx context.Context, arg UnhidePostWithCustomWitnessesParams) (Post, error) {
	row := q.db.QueryRow(ctx, unhidePostWithCustomWitnesses, arg.ID, arg.Witnesses)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.SceneID,
		&i.CharacterID,
		&i.UserID,
		&i.Blocks,
		&i.OocText,
		&i.Witnesses,
		&i.IsHidden,
		&i.IsDraft,
		&i.IsLocked,
		&i.LockedAt,
		&i.EditedByGm,
		&i.Intention,
		&i.Modifier,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const unlockPost = `-- name: UnlockPost :exec
UPDATE posts
SET
    is_locked = false,
    locked_at = NULL
WHERE id = $1
`

func (q *Queries) UnlockPost(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, unlockPost, id)
	return err
}

const updatePost = `-- name: UpdatePost :one
UPDATE posts
SET
    blocks = COALESCE($2, blocks),
    ooc_text = COALESCE($3, ooc_text),
    intention = COALESCE($4, intention),
    modifier = COALESCE($5, modifier),
    edited_by_gm = COALESCE($6, edited_by_gm),
    updated_at = NOW()
WHERE id = $1
RETURNING id, scene_id, character_id, user_id, blocks, ooc_text, witnesses, is_hidden, is_draft, is_locked, locked_at, edited_by_gm, intention, modifier, created_at, updated_at
`

type UpdatePostParams struct {
	ID         pgtype.UUID `json:"id"`
	Blocks     []byte      `json:"blocks"`
	OocText    pgtype.Text `json:"ooc_text"`
	Intention  pgtype.Text `json:"intention"`
	Modifier   pgtype.Int4 `json:"modifier"`
	EditedByGm bool        `json:"edited_by_gm"`
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, updatePost,
		arg.ID,
		arg.Blocks,
		arg.OocText,
		arg.Intention,
		arg.Modifier,
		arg.EditedByGm,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.SceneID,
		&i.CharacterID,
		&i.UserID,
		&i.Blocks,
		&i.OocText,
		&i.Witnesses,
		&i.IsHidden,
		&i.IsDraft,
		&i.IsLocked,
		&i.LockedAt,
		&i.EditedByGm,
		&i.Intention,
		&i.Modifier,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePostWitnesses = `-- name: UpdatePostWitnesses :exec
UPDATE posts
SET
    witnesses = $2,
    is_hidden = false,
    updated_at = NOW()
WHERE id = $1
`

type UpdatePostWitnessesParams struct {
	ID        pgtype.UUID   `json:"id"`
	Witnesses []pgtype.UUID `json:"witnesses"`
}

func (q *Queries) UpdatePostWitnesses(ctx context.Context, arg UpdatePostWitnessesParams) error {
	_, err := q.db.Exec(ctx, updatePostWitnesses, arg.ID, arg.Witnesses)
	return err
}
