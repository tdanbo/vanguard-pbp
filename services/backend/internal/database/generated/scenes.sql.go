// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: scenes.sql

package generated

import (
	"context"
	"encoding/json"

	"github.com/jackc/pgx/v5/pgtype"
)

const addCharacterToScene = `-- name: AddCharacterToScene :one
UPDATE scenes
SET
    character_ids = array_append(character_ids, $2::uuid),
    updated_at = NOW()
WHERE id = $1 AND NOT ($2::uuid = ANY(character_ids))
RETURNING id, campaign_id, title, description, header_image_url, character_ids, pass_states, is_archived, created_at, updated_at
`

type AddCharacterToSceneParams struct {
	ID      pgtype.UUID `json:"id"`
	Column2 pgtype.UUID `json:"column_2"`
}

func (q *Queries) AddCharacterToScene(ctx context.Context, arg AddCharacterToSceneParams) (Scene, error) {
	row := q.db.QueryRow(ctx, addCharacterToScene, arg.ID, arg.Column2)
	var i Scene
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Title,
		&i.Description,
		&i.HeaderImageUrl,
		&i.CharacterIds,
		&i.PassStates,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const archiveScene = `-- name: ArchiveScene :one
UPDATE scenes
SET
    is_archived = true,
    updated_at = NOW()
WHERE id = $1
RETURNING id, campaign_id, title, description, header_image_url, character_ids, pass_states, is_archived, created_at, updated_at
`

func (q *Queries) ArchiveScene(ctx context.Context, id pgtype.UUID) (Scene, error) {
	row := q.db.QueryRow(ctx, archiveScene, id)
	var i Scene
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Title,
		&i.Description,
		&i.HeaderImageUrl,
		&i.CharacterIds,
		&i.PassStates,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const checkAllCharactersPassed = `-- name: CheckAllCharactersPassed :one
SELECT NOT EXISTS (
    SELECT 1
    FROM characters c
    INNER JOIN scenes s ON c.id = ANY(s.character_ids)
    WHERE s.campaign_id = $1
      AND s.is_archived = false
      AND c.is_archived = false
      AND c.character_type = 'pc'  -- Only PCs need to pass
      AND (
        s.pass_states->c.id::text IS NULL
        OR s.pass_states->c.id::text = '"none"'
      )
) AS all_passed
`

// Returns true if all PCs in active scenes have passed
// Only PCs need to pass, NPCs are excluded from this check
func (q *Queries) CheckAllCharactersPassed(ctx context.Context, campaignID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkAllCharactersPassed, campaignID)
	var all_passed bool
	err := row.Scan(&all_passed)
	return all_passed, err
}

const clearCharacterPassState = `-- name: ClearCharacterPassState :one
UPDATE scenes
SET
    pass_states = pass_states - $2::text,
    updated_at = NOW()
WHERE id = $1
RETURNING id, campaign_id, title, description, header_image_url, character_ids, pass_states, is_archived, created_at, updated_at
`

type ClearCharacterPassStateParams struct {
	ID      pgtype.UUID `json:"id"`
	Column2 string      `json:"column_2"`
}

func (q *Queries) ClearCharacterPassState(ctx context.Context, arg ClearCharacterPassStateParams) (Scene, error) {
	row := q.db.QueryRow(ctx, clearCharacterPassState, arg.ID, arg.Column2)
	var i Scene
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Title,
		&i.Description,
		&i.HeaderImageUrl,
		&i.CharacterIds,
		&i.PassStates,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const clearSceneHeaderImage = `-- name: ClearSceneHeaderImage :one
UPDATE scenes
SET
    header_image_url = NULL,
    updated_at = NOW()
WHERE id = $1
RETURNING id, campaign_id, title, description, header_image_url, character_ids, pass_states, is_archived, created_at, updated_at
`

func (q *Queries) ClearSceneHeaderImage(ctx context.Context, id pgtype.UUID) (Scene, error) {
	row := q.db.QueryRow(ctx, clearSceneHeaderImage, id)
	var i Scene
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Title,
		&i.Description,
		&i.HeaderImageUrl,
		&i.CharacterIds,
		&i.PassStates,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countActiveScenes = `-- name: CountActiveScenes :one
SELECT COUNT(*) FROM scenes WHERE campaign_id = $1 AND is_archived = false
`

func (q *Queries) CountActiveScenes(ctx context.Context, campaignID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveScenes, campaignID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCampaignScenes = `-- name: CountCampaignScenes :one
SELECT COUNT(*) FROM scenes WHERE campaign_id = $1
`

func (q *Queries) CountCampaignScenes(ctx context.Context, campaignID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countCampaignScenes, campaignID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPassedCharactersInCampaign = `-- name: CountPassedCharactersInCampaign :one
SELECT COUNT(DISTINCT sub.character_id)
FROM (
    SELECT c.id AS character_id
    FROM characters c
    INNER JOIN scenes s ON c.id = ANY(s.character_ids)
    WHERE s.campaign_id = $1
      AND s.is_archived = false
      AND c.is_archived = false
      AND c.character_type = 'pc'  -- Only PCs
    GROUP BY c.id
    HAVING bool_and(
        s.pass_states->c.id::text IS NOT NULL
        AND s.pass_states->c.id::text != '"none"'
    )
) sub
`

// Count PCs that have passed in all their scenes
func (q *Queries) CountPassedCharactersInCampaign(ctx context.Context, campaignID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPassedCharactersInCampaign, campaignID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnpassedCharactersInCampaign = `-- name: CountUnpassedCharactersInCampaign :one
SELECT COUNT(DISTINCT c.id)
FROM characters c
INNER JOIN scenes s ON c.id = ANY(s.character_ids)
WHERE s.campaign_id = $1
  AND s.is_archived = false
  AND c.is_archived = false
  AND c.character_type = 'pc'  -- Only PCs
  AND (
    s.pass_states->c.id::text IS NULL
    OR s.pass_states->c.id::text = '"none"'
  )
`

// Count PCs that haven't passed in at least one scene
func (q *Queries) CountUnpassedCharactersInCampaign(ctx context.Context, campaignID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUnpassedCharactersInCampaign, campaignID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createScene = `-- name: CreateScene :one
INSERT INTO scenes (
    campaign_id,
    title,
    description
) VALUES (
    $1, $2, $3
)
RETURNING id, campaign_id, title, description, header_image_url, character_ids, pass_states, is_archived, created_at, updated_at
`

type CreateSceneParams struct {
	CampaignID  pgtype.UUID `json:"campaign_id"`
	Title       string      `json:"title"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) CreateScene(ctx context.Context, arg CreateSceneParams) (Scene, error) {
	row := q.db.QueryRow(ctx, createScene, arg.CampaignID, arg.Title, arg.Description)
	var i Scene
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Title,
		&i.Description,
		&i.HeaderImageUrl,
		&i.CharacterIds,
		&i.PassStates,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decrementSceneCount = `-- name: DecrementSceneCount :exec
UPDATE campaigns
SET
    scene_count = GREATEST(scene_count - 1, 0),
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DecrementSceneCount(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, decrementSceneCount, id)
	return err
}

const deleteScene = `-- name: DeleteScene :exec
DELETE FROM scenes WHERE id = $1
`

func (q *Queries) DeleteScene(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteScene, id)
	return err
}

const getActiveCharactersInCampaign = `-- name: GetActiveCharactersInCampaign :many
SELECT DISTINCT c.id, c.display_name, c.campaign_id, ca.user_id AS assigned_user_id
FROM characters c
LEFT JOIN character_assignments ca ON c.id = ca.character_id
WHERE c.campaign_id = $1
  AND c.is_archived = false
  AND EXISTS (
    SELECT 1 FROM scenes s
    WHERE s.campaign_id = $1
      AND s.is_archived = false
      AND c.id = ANY(s.character_ids)
  )
`

type GetActiveCharactersInCampaignRow struct {
	ID             pgtype.UUID `json:"id"`
	DisplayName    string      `json:"display_name"`
	CampaignID     pgtype.UUID `json:"campaign_id"`
	AssignedUserID pgtype.UUID `json:"assigned_user_id"`
}

// Returns all non-archived characters in active scenes for a campaign
func (q *Queries) GetActiveCharactersInCampaign(ctx context.Context, campaignID pgtype.UUID) ([]GetActiveCharactersInCampaignRow, error) {
	rows, err := q.db.Query(ctx, getActiveCharactersInCampaign, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveCharactersInCampaignRow
	for rows.Next() {
		var i GetActiveCharactersInCampaignRow
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.CampaignID,
			&i.AssignedUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllActiveScenesInCampaign = `-- name: GetAllActiveScenesInCampaign :many
SELECT id, campaign_id, title, description, header_image_url, character_ids, pass_states, is_archived, created_at, updated_at FROM scenes
WHERE campaign_id = $1 AND is_archived = false
ORDER BY created_at
`

// Returns all non-archived scenes in a campaign for auto-pass processing
func (q *Queries) GetAllActiveScenesInCampaign(ctx context.Context, campaignID pgtype.UUID) ([]Scene, error) {
	rows, err := q.db.Query(ctx, getAllActiveScenesInCampaign, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Scene
	for rows.Next() {
		var i Scene
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.Title,
			&i.Description,
			&i.HeaderImageUrl,
			&i.CharacterIds,
			&i.PassStates,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPassStatesInCampaign = `-- name: GetAllPassStatesInCampaign :many
SELECT
    s.id AS scene_id,
    s.title AS scene_title,
    s.pass_states,
    s.character_ids
FROM scenes s
WHERE s.campaign_id = $1
  AND s.is_archived = false
ORDER BY s.created_at
`

type GetAllPassStatesInCampaignRow struct {
	SceneID      pgtype.UUID     `json:"scene_id"`
	SceneTitle   string          `json:"scene_title"`
	PassStates   json.RawMessage `json:"pass_states"`
	CharacterIds []pgtype.UUID   `json:"character_ids"`
}

func (q *Queries) GetAllPassStatesInCampaign(ctx context.Context, campaignID pgtype.UUID) ([]GetAllPassStatesInCampaignRow, error) {
	rows, err := q.db.Query(ctx, getAllPassStatesInCampaign, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPassStatesInCampaignRow
	for rows.Next() {
		var i GetAllPassStatesInCampaignRow
		if err := rows.Scan(
			&i.SceneID,
			&i.SceneTitle,
			&i.PassStates,
			&i.CharacterIds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCharacterPassStatus = `-- name: GetCharacterPassStatus :one
SELECT
    c.id AS character_id,
    c.display_name,
    jsonb_agg(
        jsonb_build_object(
            'scene_id', s.id,
            'scene_title', s.title,
            'pass_state', COALESCE(s.pass_states->c.id::text, '"none"')
        )
    ) AS scenes_pass_states
FROM characters c
INNER JOIN scenes s ON c.id = ANY(s.character_ids)
WHERE c.id = $1
  AND s.is_archived = false
GROUP BY c.id, c.display_name
`

type GetCharacterPassStatusRow struct {
	CharacterID      pgtype.UUID `json:"character_id"`
	DisplayName      string      `json:"display_name"`
	ScenesPassStates []byte      `json:"scenes_pass_states"`
}

// Get pass status for a specific character across all their scenes
func (q *Queries) GetCharacterPassStatus(ctx context.Context, id pgtype.UUID) (GetCharacterPassStatusRow, error) {
	row := q.db.QueryRow(ctx, getCharacterPassStatus, id)
	var i GetCharacterPassStatusRow
	err := row.Scan(&i.CharacterID, &i.DisplayName, &i.ScenesPassStates)
	return i, err
}

const getOldestArchivedScene = `-- name: GetOldestArchivedScene :one
SELECT id, campaign_id, title, description, header_image_url, character_ids, pass_states, is_archived, created_at, updated_at FROM scenes
WHERE campaign_id = $1 AND is_archived = true
ORDER BY updated_at ASC
LIMIT 1
`

func (q *Queries) GetOldestArchivedScene(ctx context.Context, campaignID pgtype.UUID) (Scene, error) {
	row := q.db.QueryRow(ctx, getOldestArchivedScene, campaignID)
	var i Scene
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Title,
		&i.Description,
		&i.HeaderImageUrl,
		&i.CharacterIds,
		&i.PassStates,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPresentCharactersInScene = `-- name: GetPresentCharactersInScene :many
SELECT c.id
FROM characters c
WHERE c.id = ANY(
    SELECT unnest(character_ids) FROM scenes WHERE scenes.id = $1
)
AND c.is_archived = false
`

// Returns all characters currently in a scene (for witness capture)
func (q *Queries) GetPresentCharactersInScene(ctx context.Context, id pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getPresentCharactersInScene, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScene = `-- name: GetScene :one
SELECT id, campaign_id, title, description, header_image_url, character_ids, pass_states, is_archived, created_at, updated_at FROM scenes WHERE id = $1
`

func (q *Queries) GetScene(ctx context.Context, id pgtype.UUID) (Scene, error) {
	row := q.db.QueryRow(ctx, getScene, id)
	var i Scene
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Title,
		&i.Description,
		&i.HeaderImageUrl,
		&i.CharacterIds,
		&i.PassStates,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSceneCampaignID = `-- name: GetSceneCampaignID :one
SELECT campaign_id FROM scenes WHERE id = $1
`

func (q *Queries) GetSceneCampaignID(ctx context.Context, id pgtype.UUID) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getSceneCampaignID, id)
	var campaign_id pgtype.UUID
	err := row.Scan(&campaign_id)
	return campaign_id, err
}

const getSceneCharacters = `-- name: GetSceneCharacters :many
SELECT c.id, c.campaign_id, c.display_name, c.description, c.avatar_url, c.character_type, c.is_archived, c.created_at, c.updated_at, ca.user_id AS assigned_user_id, ca.assigned_at
FROM characters c
LEFT JOIN character_assignments ca ON c.id = ca.character_id
WHERE c.id = ANY(
    SELECT unnest(character_ids) FROM scenes WHERE scenes.id = $1
)
ORDER BY c.display_name
`

type GetSceneCharactersRow struct {
	ID             pgtype.UUID        `json:"id"`
	CampaignID     pgtype.UUID        `json:"campaign_id"`
	DisplayName    string             `json:"display_name"`
	Description    pgtype.Text        `json:"description"`
	AvatarUrl      pgtype.Text        `json:"avatar_url"`
	CharacterType  CharacterType      `json:"character_type"`
	IsArchived     bool               `json:"is_archived"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	AssignedUserID pgtype.UUID        `json:"assigned_user_id"`
	AssignedAt     pgtype.Timestamptz `json:"assigned_at"`
}

func (q *Queries) GetSceneCharacters(ctx context.Context, id pgtype.UUID) ([]GetSceneCharactersRow, error) {
	rows, err := q.db.Query(ctx, getSceneCharacters, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSceneCharactersRow
	for rows.Next() {
		var i GetSceneCharactersRow
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.DisplayName,
			&i.Description,
			&i.AvatarUrl,
			&i.CharacterType,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AssignedUserID,
			&i.AssignedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScenePassStates = `-- name: GetScenePassStates :one

SELECT pass_states FROM scenes WHERE id = $1
`

// ============================================
// PASS SYSTEM QUERIES
// ============================================
func (q *Queries) GetScenePassStates(ctx context.Context, id pgtype.UUID) (json.RawMessage, error) {
	row := q.db.QueryRow(ctx, getScenePassStates, id)
	var pass_states json.RawMessage
	err := row.Scan(&pass_states)
	return pass_states, err
}

const getSceneWithCampaign = `-- name: GetSceneWithCampaign :one
SELECT
    s.id, s.campaign_id, s.title, s.description, s.header_image_url, s.character_ids, s.pass_states, s.is_archived, s.created_at, s.updated_at,
    c.current_phase,
    c.current_phase_expires_at,
    c.owner_id AS campaign_owner_id
FROM scenes s
INNER JOIN campaigns c ON s.campaign_id = c.id
WHERE s.id = $1
`

type GetSceneWithCampaignRow struct {
	ID                    pgtype.UUID        `json:"id"`
	CampaignID            pgtype.UUID        `json:"campaign_id"`
	Title                 string             `json:"title"`
	Description           pgtype.Text        `json:"description"`
	HeaderImageUrl        pgtype.Text        `json:"header_image_url"`
	CharacterIds          []pgtype.UUID      `json:"character_ids"`
	PassStates            json.RawMessage    `json:"pass_states"`
	IsArchived            bool               `json:"is_archived"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	CurrentPhase          CampaignPhase      `json:"current_phase"`
	CurrentPhaseExpiresAt pgtype.Timestamptz `json:"current_phase_expires_at"`
	CampaignOwnerID       pgtype.UUID        `json:"campaign_owner_id"`
}

func (q *Queries) GetSceneWithCampaign(ctx context.Context, id pgtype.UUID) (GetSceneWithCampaignRow, error) {
	row := q.db.QueryRow(ctx, getSceneWithCampaign, id)
	var i GetSceneWithCampaignRow
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Title,
		&i.Description,
		&i.HeaderImageUrl,
		&i.CharacterIds,
		&i.PassStates,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrentPhase,
		&i.CurrentPhaseExpiresAt,
		&i.CampaignOwnerID,
	)
	return i, err
}

const getSceneWithCharacter = `-- name: GetSceneWithCharacter :one
SELECT id, campaign_id, title, description, header_image_url, character_ids, pass_states, is_archived, created_at, updated_at FROM scenes
WHERE campaign_id = $1 AND $2::uuid = ANY(character_ids) AND is_archived = false
LIMIT 1
`

type GetSceneWithCharacterParams struct {
	CampaignID pgtype.UUID `json:"campaign_id"`
	Column2    pgtype.UUID `json:"column_2"`
}

func (q *Queries) GetSceneWithCharacter(ctx context.Context, arg GetSceneWithCharacterParams) (Scene, error) {
	row := q.db.QueryRow(ctx, getSceneWithCharacter, arg.CampaignID, arg.Column2)
	var i Scene
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Title,
		&i.Description,
		&i.HeaderImageUrl,
		&i.CharacterIds,
		&i.PassStates,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVisibleScenesForCharacter = `-- name: GetVisibleScenesForCharacter :many
SELECT DISTINCT s.id, s.campaign_id, s.title, s.description, s.header_image_url, s.character_ids, s.pass_states, s.is_archived, s.created_at, s.updated_at
FROM scenes s
INNER JOIN posts p ON p.scene_id = s.id
WHERE s.campaign_id = $1
  AND $2::uuid = ANY(p.witnesses)
  AND s.is_archived = false
ORDER BY s.created_at DESC
`

type GetVisibleScenesForCharacterParams struct {
	CampaignID pgtype.UUID `json:"campaign_id"`
	Column2    pgtype.UUID `json:"column_2"`
}

// Returns scenes where the character has witnessed at least one post
func (q *Queries) GetVisibleScenesForCharacter(ctx context.Context, arg GetVisibleScenesForCharacterParams) ([]Scene, error) {
	rows, err := q.db.Query(ctx, getVisibleScenesForCharacter, arg.CampaignID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Scene
	for rows.Next() {
		var i Scene
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.Title,
			&i.Description,
			&i.HeaderImageUrl,
			&i.CharacterIds,
			&i.PassStates,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVisibleScenesForUser = `-- name: GetVisibleScenesForUser :many
SELECT DISTINCT s.id, s.campaign_id, s.title, s.description, s.header_image_url, s.character_ids, s.pass_states, s.is_archived, s.created_at, s.updated_at
FROM scenes s
INNER JOIN posts p ON p.scene_id = s.id
INNER JOIN character_assignments ca ON ca.character_id = ANY(p.witnesses)
WHERE s.campaign_id = $1
  AND ca.user_id = $2
  AND s.is_archived = false
ORDER BY s.created_at ASC
`

type GetVisibleScenesForUserParams struct {
	CampaignID pgtype.UUID `json:"campaign_id"`
	UserID     pgtype.UUID `json:"user_id"`
}

// Returns scenes where any of the user's assigned characters have witnessed posts
// Used for fog of war filtering - aggregates visibility across all user's characters
func (q *Queries) GetVisibleScenesForUser(ctx context.Context, arg GetVisibleScenesForUserParams) ([]Scene, error) {
	rows, err := q.db.Query(ctx, getVisibleScenesForUser, arg.CampaignID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Scene
	for rows.Next() {
		var i Scene
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.Title,
			&i.Description,
			&i.HeaderImageUrl,
			&i.CharacterIds,
			&i.PassStates,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementSceneCount = `-- name: IncrementSceneCount :exec
UPDATE campaigns
SET
    scene_count = scene_count + 1,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) IncrementSceneCount(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, incrementSceneCount, id)
	return err
}

const isCharacterInScene = `-- name: IsCharacterInScene :one
SELECT EXISTS(
    SELECT 1 FROM scenes
    WHERE id = $1 AND $2::uuid = ANY(character_ids)
) AS in_scene
`

type IsCharacterInSceneParams struct {
	ID      pgtype.UUID `json:"id"`
	Column2 pgtype.UUID `json:"column_2"`
}

func (q *Queries) IsCharacterInScene(ctx context.Context, arg IsCharacterInSceneParams) (bool, error) {
	row := q.db.QueryRow(ctx, isCharacterInScene, arg.ID, arg.Column2)
	var in_scene bool
	err := row.Scan(&in_scene)
	return in_scene, err
}

const listActiveScenes = `-- name: ListActiveScenes :many
SELECT id, campaign_id, title, description, header_image_url, character_ids, pass_states, is_archived, created_at, updated_at FROM scenes
WHERE campaign_id = $1 AND is_archived = false
ORDER BY created_at ASC
`

func (q *Queries) ListActiveScenes(ctx context.Context, campaignID pgtype.UUID) ([]Scene, error) {
	rows, err := q.db.Query(ctx, listActiveScenes, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Scene
	for rows.Next() {
		var i Scene
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.Title,
			&i.Description,
			&i.HeaderImageUrl,
			&i.CharacterIds,
			&i.PassStates,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCampaignScenes = `-- name: ListCampaignScenes :many
SELECT id, campaign_id, title, description, header_image_url, character_ids, pass_states, is_archived, created_at, updated_at FROM scenes
WHERE campaign_id = $1
ORDER BY is_archived ASC, created_at ASC
`

func (q *Queries) ListCampaignScenes(ctx context.Context, campaignID pgtype.UUID) ([]Scene, error) {
	rows, err := q.db.Query(ctx, listCampaignScenes, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Scene
	for rows.Next() {
		var i Scene
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.Title,
			&i.Description,
			&i.HeaderImageUrl,
			&i.CharacterIds,
			&i.PassStates,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeCharacterFromAllScenes = `-- name: RemoveCharacterFromAllScenes :exec
UPDATE scenes
SET
    character_ids = array_remove(character_ids, $2::uuid),
    updated_at = NOW()
WHERE campaign_id = $1 AND $2::uuid = ANY(character_ids)
`

type RemoveCharacterFromAllScenesParams struct {
	CampaignID pgtype.UUID `json:"campaign_id"`
	Column2    pgtype.UUID `json:"column_2"`
}

func (q *Queries) RemoveCharacterFromAllScenes(ctx context.Context, arg RemoveCharacterFromAllScenesParams) error {
	_, err := q.db.Exec(ctx, removeCharacterFromAllScenes, arg.CampaignID, arg.Column2)
	return err
}

const removeCharacterFromScene = `-- name: RemoveCharacterFromScene :one
UPDATE scenes
SET
    character_ids = array_remove(character_ids, $2::uuid),
    updated_at = NOW()
WHERE id = $1
RETURNING id, campaign_id, title, description, header_image_url, character_ids, pass_states, is_archived, created_at, updated_at
`

type RemoveCharacterFromSceneParams struct {
	ID      pgtype.UUID `json:"id"`
	Column2 pgtype.UUID `json:"column_2"`
}

func (q *Queries) RemoveCharacterFromScene(ctx context.Context, arg RemoveCharacterFromSceneParams) (Scene, error) {
	row := q.db.QueryRow(ctx, removeCharacterFromScene, arg.ID, arg.Column2)
	var i Scene
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Title,
		&i.Description,
		&i.HeaderImageUrl,
		&i.CharacterIds,
		&i.PassStates,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const resetAllPassStatesInCampaign = `-- name: ResetAllPassStatesInCampaign :exec
UPDATE scenes
SET
    pass_states = '{}'::jsonb,
    updated_at = NOW()
WHERE campaign_id = $1
`

func (q *Queries) ResetAllPassStatesInCampaign(ctx context.Context, campaignID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, resetAllPassStatesInCampaign, campaignID)
	return err
}

const resetAllPassStatesInScene = `-- name: ResetAllPassStatesInScene :one
UPDATE scenes
SET
    pass_states = '{}'::jsonb,
    updated_at = NOW()
WHERE id = $1
RETURNING id, campaign_id, title, description, header_image_url, character_ids, pass_states, is_archived, created_at, updated_at
`

func (q *Queries) ResetAllPassStatesInScene(ctx context.Context, id pgtype.UUID) (Scene, error) {
	row := q.db.QueryRow(ctx, resetAllPassStatesInScene, id)
	var i Scene
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Title,
		&i.Description,
		&i.HeaderImageUrl,
		&i.CharacterIds,
		&i.PassStates,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setCharacterPassState = `-- name: SetCharacterPassState :one
UPDATE scenes
SET
    pass_states = jsonb_set(
        COALESCE(pass_states, '{}'::jsonb),
        ARRAY[$2::text],
        to_jsonb($3::text),
        true
    ),
    updated_at = NOW()
WHERE id = $1
RETURNING id, campaign_id, title, description, header_image_url, character_ids, pass_states, is_archived, created_at, updated_at
`

type SetCharacterPassStateParams struct {
	ID      pgtype.UUID `json:"id"`
	Column2 string      `json:"column_2"`
	Column3 string      `json:"column_3"`
}

func (q *Queries) SetCharacterPassState(ctx context.Context, arg SetCharacterPassStateParams) (Scene, error) {
	row := q.db.QueryRow(ctx, setCharacterPassState, arg.ID, arg.Column2, arg.Column3)
	var i Scene
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Title,
		&i.Description,
		&i.HeaderImageUrl,
		&i.CharacterIds,
		&i.PassStates,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const unarchiveScene = `-- name: UnarchiveScene :one
UPDATE scenes
SET
    is_archived = false,
    updated_at = NOW()
WHERE id = $1
RETURNING id, campaign_id, title, description, header_image_url, character_ids, pass_states, is_archived, created_at, updated_at
`

func (q *Queries) UnarchiveScene(ctx context.Context, id pgtype.UUID) (Scene, error) {
	row := q.db.QueryRow(ctx, unarchiveScene, id)
	var i Scene
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Title,
		&i.Description,
		&i.HeaderImageUrl,
		&i.CharacterIds,
		&i.PassStates,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateScene = `-- name: UpdateScene :one
UPDATE scenes
SET
    title = COALESCE($2, title),
    description = COALESCE($3, description),
    header_image_url = COALESCE($4, header_image_url),
    updated_at = NOW()
WHERE id = $1
RETURNING id, campaign_id, title, description, header_image_url, character_ids, pass_states, is_archived, created_at, updated_at
`

type UpdateSceneParams struct {
	ID             pgtype.UUID `json:"id"`
	Title          string      `json:"title"`
	Description    pgtype.Text `json:"description"`
	HeaderImageUrl pgtype.Text `json:"header_image_url"`
}

func (q *Queries) UpdateScene(ctx context.Context, arg UpdateSceneParams) (Scene, error) {
	row := q.db.QueryRow(ctx, updateScene,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.HeaderImageUrl,
	)
	var i Scene
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Title,
		&i.Description,
		&i.HeaderImageUrl,
		&i.CharacterIds,
		&i.PassStates,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSceneHeaderImage = `-- name: UpdateSceneHeaderImage :one
UPDATE scenes
SET
    header_image_url = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, campaign_id, title, description, header_image_url, character_ids, pass_states, is_archived, created_at, updated_at
`

type UpdateSceneHeaderImageParams struct {
	ID             pgtype.UUID `json:"id"`
	HeaderImageUrl pgtype.Text `json:"header_image_url"`
}

func (q *Queries) UpdateSceneHeaderImage(ctx context.Context, arg UpdateSceneHeaderImageParams) (Scene, error) {
	row := q.db.QueryRow(ctx, updateSceneHeaderImage, arg.ID, arg.HeaderImageUrl)
	var i Scene
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Title,
		&i.Description,
		&i.HeaderImageUrl,
		&i.CharacterIds,
		&i.PassStates,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateScenePassStates = `-- name: UpdateScenePassStates :one
UPDATE scenes
SET
    pass_states = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, campaign_id, title, description, header_image_url, character_ids, pass_states, is_archived, created_at, updated_at
`

type UpdateScenePassStatesParams struct {
	ID         pgtype.UUID     `json:"id"`
	PassStates json.RawMessage `json:"pass_states"`
}

func (q *Queries) UpdateScenePassStates(ctx context.Context, arg UpdateScenePassStatesParams) (Scene, error) {
	row := q.db.QueryRow(ctx, updateScenePassStates, arg.ID, arg.PassStates)
	var i Scene
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Title,
		&i.Description,
		&i.HeaderImageUrl,
		&i.CharacterIds,
		&i.PassStates,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
