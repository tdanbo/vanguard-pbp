// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: compose_locks.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acquireComposeLock = `-- name: AcquireComposeLock :one
INSERT INTO compose_locks (
    scene_id,
    character_id,
    user_id,
    expires_at,
    is_hidden
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, scene_id, character_id, user_id, acquired_at, last_activity_at, expires_at, is_hidden
`

type AcquireComposeLockParams struct {
	SceneID     pgtype.UUID        `json:"scene_id"`
	CharacterID pgtype.UUID        `json:"character_id"`
	UserID      pgtype.UUID        `json:"user_id"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	IsHidden    bool               `json:"is_hidden"`
}

func (q *Queries) AcquireComposeLock(ctx context.Context, arg AcquireComposeLockParams) (ComposeLock, error) {
	row := q.db.QueryRow(ctx, acquireComposeLock,
		arg.SceneID,
		arg.CharacterID,
		arg.UserID,
		arg.ExpiresAt,
		arg.IsHidden,
	)
	var i ComposeLock
	err := row.Scan(
		&i.ID,
		&i.SceneID,
		&i.CharacterID,
		&i.UserID,
		&i.AcquiredAt,
		&i.LastActivityAt,
		&i.ExpiresAt,
		&i.IsHidden,
	)
	return i, err
}

const countSceneComposeLocks = `-- name: CountSceneComposeLocks :one
SELECT COUNT(*) FROM compose_locks WHERE scene_id = $1
`

func (q *Queries) CountSceneComposeLocks(ctx context.Context, sceneID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSceneComposeLocks, sceneID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteComposeLock = `-- name: DeleteComposeLock :exec
DELETE FROM compose_locks WHERE id = $1
`

func (q *Queries) DeleteComposeLock(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteComposeLock, id)
	return err
}

const deleteExpiredComposeLocks = `-- name: DeleteExpiredComposeLocks :exec
DELETE FROM compose_locks WHERE expires_at < $1
`

func (q *Queries) DeleteExpiredComposeLocks(ctx context.Context, expiresAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteExpiredComposeLocks, expiresAt)
	return err
}

const deleteSceneComposeLocks = `-- name: DeleteSceneComposeLocks :exec
DELETE FROM compose_locks WHERE scene_id = $1
`

func (q *Queries) DeleteSceneComposeLocks(ctx context.Context, sceneID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteSceneComposeLocks, sceneID)
	return err
}

const getComposeLock = `-- name: GetComposeLock :one
SELECT id, scene_id, character_id, user_id, acquired_at, last_activity_at, expires_at, is_hidden FROM compose_locks
WHERE scene_id = $1 AND character_id = $2
`

type GetComposeLockParams struct {
	SceneID     pgtype.UUID `json:"scene_id"`
	CharacterID pgtype.UUID `json:"character_id"`
}

func (q *Queries) GetComposeLock(ctx context.Context, arg GetComposeLockParams) (ComposeLock, error) {
	row := q.db.QueryRow(ctx, getComposeLock, arg.SceneID, arg.CharacterID)
	var i ComposeLock
	err := row.Scan(
		&i.ID,
		&i.SceneID,
		&i.CharacterID,
		&i.UserID,
		&i.AcquiredAt,
		&i.LastActivityAt,
		&i.ExpiresAt,
		&i.IsHidden,
	)
	return i, err
}

const getComposeLockByID = `-- name: GetComposeLockByID :one
SELECT id, scene_id, character_id, user_id, acquired_at, last_activity_at, expires_at, is_hidden FROM compose_locks
WHERE id = $1
`

func (q *Queries) GetComposeLockByID(ctx context.Context, id pgtype.UUID) (ComposeLock, error) {
	row := q.db.QueryRow(ctx, getComposeLockByID, id)
	var i ComposeLock
	err := row.Scan(
		&i.ID,
		&i.SceneID,
		&i.CharacterID,
		&i.UserID,
		&i.AcquiredAt,
		&i.LastActivityAt,
		&i.ExpiresAt,
		&i.IsHidden,
	)
	return i, err
}

const getComposeLockByScene = `-- name: GetComposeLockByScene :many
SELECT cl.id, cl.scene_id, cl.character_id, cl.user_id, cl.acquired_at, cl.last_activity_at, cl.expires_at, cl.is_hidden, c.display_name AS character_name, c.avatar_url AS character_avatar
FROM compose_locks cl
INNER JOIN characters c ON cl.character_id = c.id
WHERE cl.scene_id = $1
`

type GetComposeLockBySceneRow struct {
	ID              pgtype.UUID        `json:"id"`
	SceneID         pgtype.UUID        `json:"scene_id"`
	CharacterID     pgtype.UUID        `json:"character_id"`
	UserID          pgtype.UUID        `json:"user_id"`
	AcquiredAt      pgtype.Timestamptz `json:"acquired_at"`
	LastActivityAt  pgtype.Timestamptz `json:"last_activity_at"`
	ExpiresAt       pgtype.Timestamptz `json:"expires_at"`
	IsHidden        bool               `json:"is_hidden"`
	CharacterName   string             `json:"character_name"`
	CharacterAvatar pgtype.Text        `json:"character_avatar"`
}

func (q *Queries) GetComposeLockByScene(ctx context.Context, sceneID pgtype.UUID) ([]GetComposeLockBySceneRow, error) {
	rows, err := q.db.Query(ctx, getComposeLockByScene, sceneID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetComposeLockBySceneRow
	for rows.Next() {
		var i GetComposeLockBySceneRow
		if err := rows.Scan(
			&i.ID,
			&i.SceneID,
			&i.CharacterID,
			&i.UserID,
			&i.AcquiredAt,
			&i.LastActivityAt,
			&i.ExpiresAt,
			&i.IsHidden,
			&i.CharacterName,
			&i.CharacterAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getComposeLockWithHiddenInfo = `-- name: GetComposeLockWithHiddenInfo :one
SELECT
    cl.id, cl.scene_id, cl.character_id, cl.user_id, cl.acquired_at, cl.last_activity_at, cl.expires_at, cl.is_hidden,
    c.display_name AS character_name,
    c.avatar_url AS character_avatar
FROM compose_locks cl
INNER JOIN characters c ON cl.character_id = c.id
WHERE cl.scene_id = $1 AND cl.character_id = $2
`

type GetComposeLockWithHiddenInfoParams struct {
	SceneID     pgtype.UUID `json:"scene_id"`
	CharacterID pgtype.UUID `json:"character_id"`
}

type GetComposeLockWithHiddenInfoRow struct {
	ID              pgtype.UUID        `json:"id"`
	SceneID         pgtype.UUID        `json:"scene_id"`
	CharacterID     pgtype.UUID        `json:"character_id"`
	UserID          pgtype.UUID        `json:"user_id"`
	AcquiredAt      pgtype.Timestamptz `json:"acquired_at"`
	LastActivityAt  pgtype.Timestamptz `json:"last_activity_at"`
	ExpiresAt       pgtype.Timestamptz `json:"expires_at"`
	IsHidden        bool               `json:"is_hidden"`
	CharacterName   string             `json:"character_name"`
	CharacterAvatar pgtype.Text        `json:"character_avatar"`
}

func (q *Queries) GetComposeLockWithHiddenInfo(ctx context.Context, arg GetComposeLockWithHiddenInfoParams) (GetComposeLockWithHiddenInfoRow, error) {
	row := q.db.QueryRow(ctx, getComposeLockWithHiddenInfo, arg.SceneID, arg.CharacterID)
	var i GetComposeLockWithHiddenInfoRow
	err := row.Scan(
		&i.ID,
		&i.SceneID,
		&i.CharacterID,
		&i.UserID,
		&i.AcquiredAt,
		&i.LastActivityAt,
		&i.ExpiresAt,
		&i.IsHidden,
		&i.CharacterName,
		&i.CharacterAvatar,
	)
	return i, err
}

const getUserComposeLockInScene = `-- name: GetUserComposeLockInScene :one
SELECT id, scene_id, character_id, user_id, acquired_at, last_activity_at, expires_at, is_hidden FROM compose_locks
WHERE scene_id = $1 AND user_id = $2
`

type GetUserComposeLockInSceneParams struct {
	SceneID pgtype.UUID `json:"scene_id"`
	UserID  pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetUserComposeLockInScene(ctx context.Context, arg GetUserComposeLockInSceneParams) (ComposeLock, error) {
	row := q.db.QueryRow(ctx, getUserComposeLockInScene, arg.SceneID, arg.UserID)
	var i ComposeLock
	err := row.Scan(
		&i.ID,
		&i.SceneID,
		&i.CharacterID,
		&i.UserID,
		&i.AcquiredAt,
		&i.LastActivityAt,
		&i.ExpiresAt,
		&i.IsHidden,
	)
	return i, err
}

const updateComposeLockActivity = `-- name: UpdateComposeLockActivity :exec
UPDATE compose_locks
SET
    last_activity_at = $2,
    expires_at = $3
WHERE id = $1
`

type UpdateComposeLockActivityParams struct {
	ID             pgtype.UUID        `json:"id"`
	LastActivityAt pgtype.Timestamptz `json:"last_activity_at"`
	ExpiresAt      pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) UpdateComposeLockActivity(ctx context.Context, arg UpdateComposeLockActivityParams) error {
	_, err := q.db.Exec(ctx, updateComposeLockActivity, arg.ID, arg.LastActivityAt, arg.ExpiresAt)
	return err
}

const updateComposeLockHidden = `-- name: UpdateComposeLockHidden :exec
UPDATE compose_locks
SET is_hidden = $2
WHERE id = $1
`

type UpdateComposeLockHiddenParams struct {
	ID       pgtype.UUID `json:"id"`
	IsHidden bool        `json:"is_hidden"`
}

func (q *Queries) UpdateComposeLockHidden(ctx context.Context, arg UpdateComposeLockHiddenParams) error {
	_, err := q.db.Exec(ctx, updateComposeLockHidden, arg.ID, arg.IsHidden)
	return err
}
