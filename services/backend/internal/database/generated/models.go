// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package generated

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type BookmarkType string

const (
	BookmarkTypeCharacter BookmarkType = "character"
	BookmarkTypeScene     BookmarkType = "scene"
	BookmarkTypePost      BookmarkType = "post"
)

func (e *BookmarkType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BookmarkType(s)
	case string:
		*e = BookmarkType(s)
	default:
		return fmt.Errorf("unsupported scan type for BookmarkType: %T", src)
	}
	return nil
}

type NullBookmarkType struct {
	BookmarkType BookmarkType `json:"bookmark_type"`
	Valid        bool         `json:"valid"` // Valid is true if BookmarkType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBookmarkType) Scan(value interface{}) error {
	if value == nil {
		ns.BookmarkType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BookmarkType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBookmarkType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BookmarkType), nil
}

type CampaignPhase string

const (
	CampaignPhasePcPhase CampaignPhase = "pc_phase"
	CampaignPhaseGmPhase CampaignPhase = "gm_phase"
)

func (e *CampaignPhase) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CampaignPhase(s)
	case string:
		*e = CampaignPhase(s)
	default:
		return fmt.Errorf("unsupported scan type for CampaignPhase: %T", src)
	}
	return nil
}

type NullCampaignPhase struct {
	CampaignPhase CampaignPhase `json:"campaign_phase"`
	Valid         bool          `json:"valid"` // Valid is true if CampaignPhase is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCampaignPhase) Scan(value interface{}) error {
	if value == nil {
		ns.CampaignPhase, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CampaignPhase.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCampaignPhase) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CampaignPhase), nil
}

type CharacterLimit string

const (
	CharacterLimit1000  CharacterLimit = "1000"
	CharacterLimit3000  CharacterLimit = "3000"
	CharacterLimit6000  CharacterLimit = "6000"
	CharacterLimit10000 CharacterLimit = "10000"
)

func (e *CharacterLimit) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CharacterLimit(s)
	case string:
		*e = CharacterLimit(s)
	default:
		return fmt.Errorf("unsupported scan type for CharacterLimit: %T", src)
	}
	return nil
}

type NullCharacterLimit struct {
	CharacterLimit CharacterLimit `json:"character_limit"`
	Valid          bool           `json:"valid"` // Valid is true if CharacterLimit is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCharacterLimit) Scan(value interface{}) error {
	if value == nil {
		ns.CharacterLimit, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CharacterLimit.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCharacterLimit) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CharacterLimit), nil
}

type CharacterType string

const (
	CharacterTypePc  CharacterType = "pc"
	CharacterTypeNpc CharacterType = "npc"
)

func (e *CharacterType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CharacterType(s)
	case string:
		*e = CharacterType(s)
	default:
		return fmt.Errorf("unsupported scan type for CharacterType: %T", src)
	}
	return nil
}

type NullCharacterType struct {
	CharacterType CharacterType `json:"character_type"`
	Valid         bool          `json:"valid"` // Valid is true if CharacterType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCharacterType) Scan(value interface{}) error {
	if value == nil {
		ns.CharacterType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CharacterType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCharacterType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CharacterType), nil
}

type InviteStatus string

const (
	InviteStatusActive  InviteStatus = "active"
	InviteStatusUsed    InviteStatus = "used"
	InviteStatusExpired InviteStatus = "expired"
	InviteStatusRevoked InviteStatus = "revoked"
)

func (e *InviteStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InviteStatus(s)
	case string:
		*e = InviteStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for InviteStatus: %T", src)
	}
	return nil
}

type NullInviteStatus struct {
	InviteStatus InviteStatus `json:"invite_status"`
	Valid        bool         `json:"valid"` // Valid is true if InviteStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInviteStatus) Scan(value interface{}) error {
	if value == nil {
		ns.InviteStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InviteStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInviteStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InviteStatus), nil
}

type MemberRole string

const (
	MemberRoleGm     MemberRole = "gm"
	MemberRolePlayer MemberRole = "player"
)

func (e *MemberRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MemberRole(s)
	case string:
		*e = MemberRole(s)
	default:
		return fmt.Errorf("unsupported scan type for MemberRole: %T", src)
	}
	return nil
}

type NullMemberRole struct {
	MemberRole MemberRole `json:"member_role"`
	Valid      bool       `json:"valid"` // Valid is true if MemberRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMemberRole) Scan(value interface{}) error {
	if value == nil {
		ns.MemberRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MemberRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMemberRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MemberRole), nil
}

type NotificationFrequency string

const (
	NotificationFrequencyRealtime     NotificationFrequency = "realtime"
	NotificationFrequencyDigestDaily  NotificationFrequency = "digest_daily"
	NotificationFrequencyDigestWeekly NotificationFrequency = "digest_weekly"
	NotificationFrequencyOff          NotificationFrequency = "off"
)

func (e *NotificationFrequency) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = NotificationFrequency(s)
	case string:
		*e = NotificationFrequency(s)
	default:
		return fmt.Errorf("unsupported scan type for NotificationFrequency: %T", src)
	}
	return nil
}

type NullNotificationFrequency struct {
	NotificationFrequency NotificationFrequency `json:"notification_frequency"`
	Valid                 bool                  `json:"valid"` // Valid is true if NotificationFrequency is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullNotificationFrequency) Scan(value interface{}) error {
	if value == nil {
		ns.NotificationFrequency, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.NotificationFrequency.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullNotificationFrequency) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.NotificationFrequency), nil
}

type OocVisibility string

const (
	OocVisibilityAll    OocVisibility = "all"
	OocVisibilityGmOnly OocVisibility = "gm_only"
)

func (e *OocVisibility) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = OocVisibility(s)
	case string:
		*e = OocVisibility(s)
	default:
		return fmt.Errorf("unsupported scan type for OocVisibility: %T", src)
	}
	return nil
}

type NullOocVisibility struct {
	OocVisibility OocVisibility `json:"ooc_visibility"`
	Valid         bool          `json:"valid"` // Valid is true if OocVisibility is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOocVisibility) Scan(value interface{}) error {
	if value == nil {
		ns.OocVisibility, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.OocVisibility.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullOocVisibility) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.OocVisibility), nil
}

type PassState string

const (
	PassStateNone       PassState = "none"
	PassStatePassed     PassState = "passed"
	PassStateHardPassed PassState = "hard_passed"
)

func (e *PassState) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PassState(s)
	case string:
		*e = PassState(s)
	default:
		return fmt.Errorf("unsupported scan type for PassState: %T", src)
	}
	return nil
}

type NullPassState struct {
	PassState PassState `json:"pass_state"`
	Valid     bool      `json:"valid"` // Valid is true if PassState is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPassState) Scan(value interface{}) error {
	if value == nil {
		ns.PassState, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PassState.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPassState) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PassState), nil
}

type PostBlockType string

const (
	PostBlockTypeAction PostBlockType = "action"
	PostBlockTypeDialog PostBlockType = "dialog"
)

func (e *PostBlockType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PostBlockType(s)
	case string:
		*e = PostBlockType(s)
	default:
		return fmt.Errorf("unsupported scan type for PostBlockType: %T", src)
	}
	return nil
}

type NullPostBlockType struct {
	PostBlockType PostBlockType `json:"post_block_type"`
	Valid         bool          `json:"valid"` // Valid is true if PostBlockType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPostBlockType) Scan(value interface{}) error {
	if value == nil {
		ns.PostBlockType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PostBlockType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPostBlockType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PostBlockType), nil
}

type RollStatus string

const (
	RollStatusPending     RollStatus = "pending"
	RollStatusCompleted   RollStatus = "completed"
	RollStatusInvalidated RollStatus = "invalidated"
)

func (e *RollStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RollStatus(s)
	case string:
		*e = RollStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for RollStatus: %T", src)
	}
	return nil
}

type NullRollStatus struct {
	RollStatus RollStatus `json:"roll_status"`
	Valid      bool       `json:"valid"` // Valid is true if RollStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRollStatus) Scan(value interface{}) error {
	if value == nil {
		ns.RollStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RollStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRollStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RollStatus), nil
}

type TimeGatePreset string

const (
	TimeGatePreset24h TimeGatePreset = "24h"
	TimeGatePreset2d  TimeGatePreset = "2d"
	TimeGatePreset3d  TimeGatePreset = "3d"
	TimeGatePreset4d  TimeGatePreset = "4d"
	TimeGatePreset5d  TimeGatePreset = "5d"
)

func (e *TimeGatePreset) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TimeGatePreset(s)
	case string:
		*e = TimeGatePreset(s)
	default:
		return fmt.Errorf("unsupported scan type for TimeGatePreset: %T", src)
	}
	return nil
}

type NullTimeGatePreset struct {
	TimeGatePreset TimeGatePreset `json:"time_gate_preset"`
	Valid          bool           `json:"valid"` // Valid is true if TimeGatePreset is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTimeGatePreset) Scan(value interface{}) error {
	if value == nil {
		ns.TimeGatePreset, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TimeGatePreset.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTimeGatePreset) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TimeGatePreset), nil
}

type Bookmark struct {
	ID                 pgtype.UUID        `json:"id"`
	CharacterID        pgtype.UUID        `json:"character_id"`
	BookmarkType       BookmarkType       `json:"bookmark_type"`
	ReferencedEntityID pgtype.UUID        `json:"referenced_entity_id"`
	Note               pgtype.Text        `json:"note"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
}

type Campaign struct {
	ID                    pgtype.UUID        `json:"id"`
	Title                 string             `json:"title"`
	Description           pgtype.Text        `json:"description"`
	OwnerID               pgtype.UUID        `json:"owner_id"`
	Settings              []byte             `json:"settings"`
	CurrentPhase          CampaignPhase      `json:"current_phase"`
	CurrentPhaseStartedAt pgtype.Timestamptz `json:"current_phase_started_at"`
	CurrentPhaseExpiresAt pgtype.Timestamptz `json:"current_phase_expires_at"`
	IsPaused              bool               `json:"is_paused"`
	LastGmActivityAt      pgtype.Timestamptz `json:"last_gm_activity_at"`
	StorageUsedBytes      int64              `json:"storage_used_bytes"`
	SceneCount            int32              `json:"scene_count"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
}

type CampaignMember struct {
	ID         pgtype.UUID        `json:"id"`
	CampaignID pgtype.UUID        `json:"campaign_id"`
	UserID     pgtype.UUID        `json:"user_id"`
	Role       MemberRole         `json:"role"`
	JoinedAt   pgtype.Timestamptz `json:"joined_at"`
	// Out-of-character alias for the player, can be different from character names
	Alias pgtype.Text `json:"alias"`
}

type Character struct {
	ID            pgtype.UUID        `json:"id"`
	CampaignID    pgtype.UUID        `json:"campaign_id"`
	DisplayName   string             `json:"display_name"`
	Description   pgtype.Text        `json:"description"`
	AvatarUrl     pgtype.Text        `json:"avatar_url"`
	CharacterType CharacterType      `json:"character_type"`
	IsArchived    bool               `json:"is_archived"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

type CharacterAssignment struct {
	ID          pgtype.UUID        `json:"id"`
	CharacterID pgtype.UUID        `json:"character_id"`
	UserID      pgtype.UUID        `json:"user_id"`
	AssignedAt  pgtype.Timestamptz `json:"assigned_at"`
}

type ComposeDraft struct {
	ID          pgtype.UUID        `json:"id"`
	SceneID     pgtype.UUID        `json:"scene_id"`
	CharacterID pgtype.UUID        `json:"character_id"`
	UserID      pgtype.UUID        `json:"user_id"`
	Blocks      []byte             `json:"blocks"`
	OocText     pgtype.Text        `json:"ooc_text"`
	Intention   pgtype.Text        `json:"intention"`
	Modifier    pgtype.Int4        `json:"modifier"`
	IsHidden    bool               `json:"is_hidden"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

type ComposeLock struct {
	ID             pgtype.UUID        `json:"id"`
	SceneID        pgtype.UUID        `json:"scene_id"`
	CharacterID    pgtype.UUID        `json:"character_id"`
	UserID         pgtype.UUID        `json:"user_id"`
	AcquiredAt     pgtype.Timestamptz `json:"acquired_at"`
	LastActivityAt pgtype.Timestamptz `json:"last_activity_at"`
	ExpiresAt      pgtype.Timestamptz `json:"expires_at"`
	IsHidden       bool               `json:"is_hidden"`
}

type EmailDigest struct {
	ID                pgtype.UUID        `json:"id"`
	UserID            pgtype.UUID        `json:"user_id"`
	DigestType        string             `json:"digest_type"`
	SentAt            pgtype.Timestamptz `json:"sent_at"`
	NotificationCount int32              `json:"notification_count"`
	CampaignIds       []pgtype.UUID      `json:"campaign_ids"`
}

type InviteLink struct {
	ID         pgtype.UUID        `json:"id"`
	CampaignID pgtype.UUID        `json:"campaign_id"`
	Code       string             `json:"code"`
	CreatedBy  pgtype.UUID        `json:"created_by"`
	ExpiresAt  pgtype.Timestamptz `json:"expires_at"`
	UsedAt     pgtype.Timestamptz `json:"used_at"`
	UsedBy     pgtype.UUID        `json:"used_by"`
	RevokedAt  pgtype.Timestamptz `json:"revoked_at"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

type Notification struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
	Title  string      `json:"title"`
	Body   string      `json:"body"`
	// Notification types:
	// Player:
	// - pc_phase_started: PC Phase has started
	// - new_post_in_scene: New post in a scene
	// - roll_requested: GM requested a roll
	// - intention_overridden: GM changed intention
	// - character_added_to_scene: Character added to scene
	// - compose_lock_released: Compose lock released
	// - time_gate_warning_24h: 24 hours remaining
	// - time_gate_warning_6h: 6 hours remaining
	// - time_gate_warning_1h: 1 hour remaining
	// - pass_state_cleared: Pass state was cleared
	// - gm_role_available: GM role is available
	//
	// GM:
	// - all_characters_passed: All characters have passed
	// - time_gate_expired: Time gate has expired
	// - hidden_post_submitted: Hidden post was submitted
	// - player_joined: Player joined campaign
	// - player_roll_submitted: Player submitted a roll
	// - unresolved_rolls_exist: Unresolved rolls exist
	// - campaign_at_player_limit: Campaign at player limit
	// - scene_limit_warning: Scene limit warning
	//
	Type        string             `json:"type"`
	CampaignID  pgtype.UUID        `json:"campaign_id"`
	SceneID     pgtype.UUID        `json:"scene_id"`
	PostID      pgtype.UUID        `json:"post_id"`
	IsRead      bool               `json:"is_read"`
	ReadAt      pgtype.Timestamptz `json:"read_at"`
	EmailSentAt pgtype.Timestamptz `json:"email_sent_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	IsUrgent    bool               `json:"is_urgent"`
	Link        pgtype.Text        `json:"link"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	CharacterID pgtype.UUID        `json:"character_id"`
	Metadata    []byte             `json:"metadata"`
}

type NotificationPreference struct {
	ID             pgtype.UUID           `json:"id"`
	UserID         pgtype.UUID           `json:"user_id"`
	EmailEnabled   bool                  `json:"email_enabled"`
	EmailFrequency NotificationFrequency `json:"email_frequency"`
	InAppEnabled   bool                  `json:"in_app_enabled"`
	CreatedAt      pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz    `json:"updated_at"`
}

type NotificationQueue struct {
	ID             pgtype.UUID        `json:"id"`
	UserID         pgtype.UUID        `json:"user_id"`
	NotificationID pgtype.UUID        `json:"notification_id"`
	QueuedAt       pgtype.Timestamptz `json:"queued_at"`
	DeliverAfter   pgtype.Timestamptz `json:"deliver_after"`
	DeliveredAt    pgtype.Timestamptz `json:"delivered_at"`
}

type Post struct {
	ID          pgtype.UUID        `json:"id"`
	SceneID     pgtype.UUID        `json:"scene_id"`
	CharacterID pgtype.UUID        `json:"character_id"`
	UserID      pgtype.UUID        `json:"user_id"`
	Blocks      []byte             `json:"blocks"`
	OocText     pgtype.Text        `json:"ooc_text"`
	Witnesses   []pgtype.UUID      `json:"witnesses"`
	IsHidden    bool               `json:"is_hidden"`
	IsDraft     bool               `json:"is_draft"`
	IsLocked    bool               `json:"is_locked"`
	LockedAt    pgtype.Timestamptz `json:"locked_at"`
	EditedByGm  bool               `json:"edited_by_gm"`
	Intention   pgtype.Text        `json:"intention"`
	Modifier    pgtype.Int4        `json:"modifier"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

type QuietHour struct {
	ID           pgtype.UUID        `json:"id"`
	UserID       pgtype.UUID        `json:"user_id"`
	Enabled      bool               `json:"enabled"`
	StartTime    pgtype.Time        `json:"start_time"`
	EndTime      pgtype.Time        `json:"end_time"`
	Timezone     string             `json:"timezone"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	UrgentBypass bool               `json:"urgent_bypass"`
}

type Roll struct {
	ID                pgtype.UUID        `json:"id"`
	PostID            pgtype.UUID        `json:"post_id"`
	SceneID           pgtype.UUID        `json:"scene_id"`
	CharacterID       pgtype.UUID        `json:"character_id"`
	RequestedBy       pgtype.UUID        `json:"requested_by"`
	Intention         string             `json:"intention"`
	Modifier          int32              `json:"modifier"`
	DiceType          string             `json:"dice_type"`
	DiceCount         int32              `json:"dice_count"`
	Result            []int32            `json:"result"`
	Total             pgtype.Int4        `json:"total"`
	WasOverridden     bool               `json:"was_overridden"`
	OriginalIntention pgtype.Text        `json:"original_intention"`
	Status            RollStatus         `json:"status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	// GM who overrode the intention
	OverriddenBy pgtype.UUID `json:"overridden_by"`
	// Reason for intention override
	OverrideReason pgtype.Text `json:"override_reason"`
	// When intention was overridden
	OverrideTimestamp pgtype.Timestamptz `json:"override_timestamp"`
	// GM-assigned result (bypasses dice)
	ManualResult pgtype.Int4 `json:"manual_result"`
	// GM who manually resolved
	ManuallyResolvedBy pgtype.UUID `json:"manually_resolved_by"`
	// Reason for manual resolution
	ManualResolutionReason pgtype.Text `json:"manual_resolution_reason"`
	// When the roll was executed
	RolledAt pgtype.Timestamptz `json:"rolled_at"`
}

type Scene struct {
	ID             pgtype.UUID        `json:"id"`
	CampaignID     pgtype.UUID        `json:"campaign_id"`
	Title          string             `json:"title"`
	Description    pgtype.Text        `json:"description"`
	HeaderImageUrl pgtype.Text        `json:"header_image_url"`
	CharacterIds   []pgtype.UUID      `json:"character_ids"`
	PassStates     json.RawMessage    `json:"pass_states"`
	IsArchived     bool               `json:"is_archived"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}
