// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: notifications.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createNotification = `-- name: CreateNotification :one

INSERT INTO notifications (
    user_id,
    title,
    body,
    type,
    campaign_id,
    scene_id,
    post_id,
    character_id,
    is_urgent,
    link,
    metadata,
    expires_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11,
    COALESCE($12, NOW() + INTERVAL '90 days')
)
RETURNING id, user_id, title, body, type, campaign_id, scene_id, post_id, is_read, read_at, email_sent_at, created_at, is_urgent, link, expires_at, character_id, metadata
`

type CreateNotificationParams struct {
	UserID      pgtype.UUID `json:"user_id"`
	Title       string      `json:"title"`
	Body        string      `json:"body"`
	Type        string      `json:"type"`
	CampaignID  pgtype.UUID `json:"campaign_id"`
	SceneID     pgtype.UUID `json:"scene_id"`
	PostID      pgtype.UUID `json:"post_id"`
	CharacterID pgtype.UUID `json:"character_id"`
	IsUrgent    bool        `json:"is_urgent"`
	Link        pgtype.Text `json:"link"`
	Metadata    []byte      `json:"metadata"`
	Column12    interface{} `json:"column_12"`
}

// ============================================
// NOTIFICATION QUERIES
// ============================================
func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createNotification,
		arg.UserID,
		arg.Title,
		arg.Body,
		arg.Type,
		arg.CampaignID,
		arg.SceneID,
		arg.PostID,
		arg.CharacterID,
		arg.IsUrgent,
		arg.Link,
		arg.Metadata,
		arg.Column12,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Type,
		&i.CampaignID,
		&i.SceneID,
		&i.PostID,
		&i.IsRead,
		&i.ReadAt,
		&i.EmailSentAt,
		&i.CreatedAt,
		&i.IsUrgent,
		&i.Link,
		&i.ExpiresAt,
		&i.CharacterID,
		&i.Metadata,
	)
	return i, err
}

const deleteExpiredNotifications = `-- name: DeleteExpiredNotifications :execrows
DELETE FROM notifications
WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredNotifications(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, deleteExpiredNotifications)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteNotification = `-- name: DeleteNotification :exec
DELETE FROM notifications
WHERE id = $1 AND user_id = $2
`

type DeleteNotificationParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteNotification(ctx context.Context, arg DeleteNotificationParams) error {
	_, err := q.db.Exec(ctx, deleteNotification, arg.ID, arg.UserID)
	return err
}

const deleteQueuedNotification = `-- name: DeleteQueuedNotification :exec
DELETE FROM notification_queue
WHERE id = $1
`

func (q *Queries) DeleteQueuedNotification(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteQueuedNotification, id)
	return err
}

const deliverAllQueuedNotifications = `-- name: DeliverAllQueuedNotifications :execrows
UPDATE notification_queue
SET delivered_at = NOW()
WHERE user_id = $1
  AND delivered_at IS NULL
`

func (q *Queries) DeliverAllQueuedNotifications(ctx context.Context, userID pgtype.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deliverAllQueuedNotifications, userID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findSimilarNotification = `-- name: FindSimilarNotification :one
SELECT id, user_id, title, body, type, campaign_id, scene_id, post_id, is_read, read_at, email_sent_at, created_at, is_urgent, link, expires_at, character_id, metadata FROM notifications
WHERE user_id = $1
  AND campaign_id = $2
  AND type = $3
  AND created_at > $4
LIMIT 1
`

type FindSimilarNotificationParams struct {
	UserID     pgtype.UUID        `json:"user_id"`
	CampaignID pgtype.UUID        `json:"campaign_id"`
	Type       string             `json:"type"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) FindSimilarNotification(ctx context.Context, arg FindSimilarNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, findSimilarNotification,
		arg.UserID,
		arg.CampaignID,
		arg.Type,
		arg.CreatedAt,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Type,
		&i.CampaignID,
		&i.SceneID,
		&i.PostID,
		&i.IsRead,
		&i.ReadAt,
		&i.EmailSentAt,
		&i.CreatedAt,
		&i.IsUrgent,
		&i.Link,
		&i.ExpiresAt,
		&i.CharacterID,
		&i.Metadata,
	)
	return i, err
}

const getCharacterOwner = `-- name: GetCharacterOwner :one
SELECT ca.user_id FROM character_assignments ca
WHERE ca.character_id = $1
`

func (q *Queries) GetCharacterOwner(ctx context.Context, characterID pgtype.UUID) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getCharacterOwner, characterID)
	var user_id pgtype.UUID
	err := row.Scan(&user_id)
	return user_id, err
}

const getGMUserID = `-- name: GetGMUserID :one
SELECT cm.user_id FROM campaign_members cm
WHERE cm.campaign_id = $1
  AND cm.role = 'gm'
LIMIT 1
`

func (q *Queries) GetGMUserID(ctx context.Context, campaignID pgtype.UUID) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getGMUserID, campaignID)
	var user_id pgtype.UUID
	err := row.Scan(&user_id)
	return user_id, err
}

const getLastDigestSent = `-- name: GetLastDigestSent :one
SELECT id, user_id, digest_type, sent_at, notification_count, campaign_ids FROM email_digests
WHERE user_id = $1
  AND digest_type = $2
ORDER BY sent_at DESC
LIMIT 1
`

type GetLastDigestSentParams struct {
	UserID     pgtype.UUID `json:"user_id"`
	DigestType string      `json:"digest_type"`
}

func (q *Queries) GetLastDigestSent(ctx context.Context, arg GetLastDigestSentParams) (EmailDigest, error) {
	row := q.db.QueryRow(ctx, getLastDigestSent, arg.UserID, arg.DigestType)
	var i EmailDigest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DigestType,
		&i.SentAt,
		&i.NotificationCount,
		&i.CampaignIds,
	)
	return i, err
}

const getNotification = `-- name: GetNotification :one
SELECT id, user_id, title, body, type, campaign_id, scene_id, post_id, is_read, read_at, email_sent_at, created_at, is_urgent, link, expires_at, character_id, metadata FROM notifications
WHERE id = $1
`

func (q *Queries) GetNotification(ctx context.Context, id pgtype.UUID) (Notification, error) {
	row := q.db.QueryRow(ctx, getNotification, id)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Type,
		&i.CampaignID,
		&i.SceneID,
		&i.PostID,
		&i.IsRead,
		&i.ReadAt,
		&i.EmailSentAt,
		&i.CreatedAt,
		&i.IsUrgent,
		&i.Link,
		&i.ExpiresAt,
		&i.CharacterID,
		&i.Metadata,
	)
	return i, err
}

const getNotificationPreferences = `-- name: GetNotificationPreferences :one

SELECT id, user_id, email_enabled, email_frequency, in_app_enabled, created_at, updated_at FROM notification_preferences
WHERE user_id = $1
`

// ============================================
// NOTIFICATION PREFERENCES QUERIES
// ============================================
func (q *Queries) GetNotificationPreferences(ctx context.Context, userID pgtype.UUID) (NotificationPreference, error) {
	row := q.db.QueryRow(ctx, getNotificationPreferences, userID)
	var i NotificationPreference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EmailEnabled,
		&i.EmailFrequency,
		&i.InAppEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNotificationsByUser = `-- name: GetNotificationsByUser :many
SELECT id, user_id, title, body, type, campaign_id, scene_id, post_id, is_read, read_at, email_sent_at, created_at, is_urgent, link, expires_at, character_id, metadata FROM notifications
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetNotificationsByUserParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) GetNotificationsByUser(ctx context.Context, arg GetNotificationsByUserParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getNotificationsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Type,
			&i.CampaignID,
			&i.SceneID,
			&i.PostID,
			&i.IsRead,
			&i.ReadAt,
			&i.EmailSentAt,
			&i.CreatedAt,
			&i.IsUrgent,
			&i.Link,
			&i.ExpiresAt,
			&i.CharacterID,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationsSince = `-- name: GetNotificationsSince :many
SELECT id, user_id, title, body, type, campaign_id, scene_id, post_id, is_read, read_at, email_sent_at, created_at, is_urgent, link, expires_at, character_id, metadata FROM notifications
WHERE user_id = $1
  AND is_read = false
  AND created_at > $2
ORDER BY created_at DESC
`

type GetNotificationsSinceParams struct {
	UserID    pgtype.UUID        `json:"user_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetNotificationsSince(ctx context.Context, arg GetNotificationsSinceParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getNotificationsSince, arg.UserID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Type,
			&i.CampaignID,
			&i.SceneID,
			&i.PostID,
			&i.IsRead,
			&i.ReadAt,
			&i.EmailSentAt,
			&i.CreatedAt,
			&i.IsUrgent,
			&i.Link,
			&i.ExpiresAt,
			&i.CharacterID,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPCUsersInCampaign = `-- name: GetPCUsersInCampaign :many

SELECT DISTINCT ca.user_id, c.id as character_id, c.display_name
FROM characters c
JOIN character_assignments ca ON ca.character_id = c.id
WHERE c.campaign_id = $1
  AND c.character_type = 'pc'
  AND c.is_archived = false
`

type GetPCUsersInCampaignRow struct {
	UserID      pgtype.UUID `json:"user_id"`
	CharacterID pgtype.UUID `json:"character_id"`
	DisplayName string      `json:"display_name"`
}

// ============================================
// CAMPAIGN MEMBER NOTIFICATION HELPERS
// ============================================
func (q *Queries) GetPCUsersInCampaign(ctx context.Context, campaignID pgtype.UUID) ([]GetPCUsersInCampaignRow, error) {
	rows, err := q.db.Query(ctx, getPCUsersInCampaign, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPCUsersInCampaignRow
	for rows.Next() {
		var i GetPCUsersInCampaignRow
		if err := rows.Scan(&i.UserID, &i.CharacterID, &i.DisplayName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQueuedNotificationsReadyForDelivery = `-- name: GetQueuedNotificationsReadyForDelivery :many
SELECT nq.id, nq.user_id, nq.notification_id, nq.queued_at, nq.deliver_after, nq.delivered_at, n.id, n.user_id, n.title, n.body, n.type, n.campaign_id, n.scene_id, n.post_id, n.is_read, n.read_at, n.email_sent_at, n.created_at, n.is_urgent, n.link, n.expires_at, n.character_id, n.metadata FROM notification_queue nq
JOIN notifications n ON n.id = nq.notification_id
WHERE nq.deliver_after <= NOW()
  AND nq.delivered_at IS NULL
ORDER BY nq.deliver_after ASC
LIMIT 100
`

type GetQueuedNotificationsReadyForDeliveryRow struct {
	ID             pgtype.UUID        `json:"id"`
	UserID         pgtype.UUID        `json:"user_id"`
	NotificationID pgtype.UUID        `json:"notification_id"`
	QueuedAt       pgtype.Timestamptz `json:"queued_at"`
	DeliverAfter   pgtype.Timestamptz `json:"deliver_after"`
	DeliveredAt    pgtype.Timestamptz `json:"delivered_at"`
	ID_2           pgtype.UUID        `json:"id_2"`
	UserID_2       pgtype.UUID        `json:"user_id_2"`
	Title          string             `json:"title"`
	Body           string             `json:"body"`
	Type           string             `json:"type"`
	CampaignID     pgtype.UUID        `json:"campaign_id"`
	SceneID        pgtype.UUID        `json:"scene_id"`
	PostID         pgtype.UUID        `json:"post_id"`
	IsRead         bool               `json:"is_read"`
	ReadAt         pgtype.Timestamptz `json:"read_at"`
	EmailSentAt    pgtype.Timestamptz `json:"email_sent_at"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	IsUrgent       bool               `json:"is_urgent"`
	Link           pgtype.Text        `json:"link"`
	ExpiresAt      pgtype.Timestamptz `json:"expires_at"`
	CharacterID    pgtype.UUID        `json:"character_id"`
	Metadata       []byte             `json:"metadata"`
}

func (q *Queries) GetQueuedNotificationsReadyForDelivery(ctx context.Context) ([]GetQueuedNotificationsReadyForDeliveryRow, error) {
	rows, err := q.db.Query(ctx, getQueuedNotificationsReadyForDelivery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQueuedNotificationsReadyForDeliveryRow
	for rows.Next() {
		var i GetQueuedNotificationsReadyForDeliveryRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.NotificationID,
			&i.QueuedAt,
			&i.DeliverAfter,
			&i.DeliveredAt,
			&i.ID_2,
			&i.UserID_2,
			&i.Title,
			&i.Body,
			&i.Type,
			&i.CampaignID,
			&i.SceneID,
			&i.PostID,
			&i.IsRead,
			&i.ReadAt,
			&i.EmailSentAt,
			&i.CreatedAt,
			&i.IsUrgent,
			&i.Link,
			&i.ExpiresAt,
			&i.CharacterID,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuietHours = `-- name: GetQuietHours :one

SELECT id, user_id, enabled, start_time, end_time, timezone, created_at, updated_at, urgent_bypass FROM quiet_hours
WHERE user_id = $1
`

// ============================================
// QUIET HOURS QUERIES
// ============================================
func (q *Queries) GetQuietHours(ctx context.Context, userID pgtype.UUID) (QuietHour, error) {
	row := q.db.QueryRow(ctx, getQuietHours, userID)
	var i QuietHour
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Enabled,
		&i.StartTime,
		&i.EndTime,
		&i.Timezone,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UrgentBypass,
	)
	return i, err
}

const getUnreadNotificationCount = `-- name: GetUnreadNotificationCount :one
SELECT COUNT(*) FROM notifications
WHERE user_id = $1
  AND is_read = false
`

func (q *Queries) GetUnreadNotificationCount(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getUnreadNotificationCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUnreadNotificationCountByCampaign = `-- name: GetUnreadNotificationCountByCampaign :one
SELECT COUNT(*) FROM notifications
WHERE user_id = $1
  AND campaign_id = $2
  AND is_read = false
`

type GetUnreadNotificationCountByCampaignParams struct {
	UserID     pgtype.UUID `json:"user_id"`
	CampaignID pgtype.UUID `json:"campaign_id"`
}

func (q *Queries) GetUnreadNotificationCountByCampaign(ctx context.Context, arg GetUnreadNotificationCountByCampaignParams) (int64, error) {
	row := q.db.QueryRow(ctx, getUnreadNotificationCountByCampaign, arg.UserID, arg.CampaignID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUnreadNotificationsByUser = `-- name: GetUnreadNotificationsByUser :many
SELECT id, user_id, title, body, type, campaign_id, scene_id, post_id, is_read, read_at, email_sent_at, created_at, is_urgent, link, expires_at, character_id, metadata FROM notifications
WHERE user_id = $1
  AND is_read = false
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetUnreadNotificationsByUserParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) GetUnreadNotificationsByUser(ctx context.Context, arg GetUnreadNotificationsByUserParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getUnreadNotificationsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Type,
			&i.CampaignID,
			&i.SceneID,
			&i.PostID,
			&i.IsRead,
			&i.ReadAt,
			&i.EmailSentAt,
			&i.CreatedAt,
			&i.IsUrgent,
			&i.Link,
			&i.ExpiresAt,
			&i.CharacterID,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserQueuedCount = `-- name: GetUserQueuedCount :one
SELECT COUNT(*) FROM notification_queue
WHERE user_id = $1
  AND delivered_at IS NULL
`

func (q *Queries) GetUserQueuedCount(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getUserQueuedCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserQueuedNotifications = `-- name: GetUserQueuedNotifications :many
SELECT id, user_id, notification_id, queued_at, deliver_after, delivered_at FROM notification_queue
WHERE user_id = $1
  AND delivered_at IS NULL
ORDER BY queued_at ASC
`

func (q *Queries) GetUserQueuedNotifications(ctx context.Context, userID pgtype.UUID) ([]NotificationQueue, error) {
	rows, err := q.db.Query(ctx, getUserQueuedNotifications, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NotificationQueue
	for rows.Next() {
		var i NotificationQueue
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.NotificationID,
			&i.QueuedAt,
			&i.DeliverAfter,
			&i.DeliveredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersInScene = `-- name: GetUsersInScene :many
SELECT DISTINCT ca.user_id, ca.character_id
FROM character_assignments ca
JOIN scenes s ON ca.character_id = ANY(s.character_ids)
WHERE s.id = $1
`

type GetUsersInSceneRow struct {
	UserID      pgtype.UUID `json:"user_id"`
	CharacterID pgtype.UUID `json:"character_id"`
}

func (q *Queries) GetUsersInScene(ctx context.Context, id pgtype.UUID) ([]GetUsersInSceneRow, error) {
	rows, err := q.db.Query(ctx, getUsersInScene, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersInSceneRow
	for rows.Next() {
		var i GetUsersInSceneRow
		if err := rows.Scan(&i.UserID, &i.CharacterID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithDigestPreference = `-- name: GetUsersWithDigestPreference :many
SELECT id, user_id, email_enabled, email_frequency, in_app_enabled, created_at, updated_at FROM notification_preferences
WHERE email_frequency = $1
  AND email_enabled = true
`

func (q *Queries) GetUsersWithDigestPreference(ctx context.Context, emailFrequency NotificationFrequency) ([]NotificationPreference, error) {
	rows, err := q.db.Query(ctx, getUsersWithDigestPreference, emailFrequency)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NotificationPreference
	for rows.Next() {
		var i NotificationPreference
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EmailEnabled,
			&i.EmailFrequency,
			&i.InAppEnabled,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWitnessUsers = `-- name: GetWitnessUsers :many
SELECT DISTINCT ca.user_id FROM character_assignments ca
WHERE ca.character_id = ANY($1::uuid[])
`

func (q *Queries) GetWitnessUsers(ctx context.Context, dollar_1 []pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getWitnessUsers, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var user_id pgtype.UUID
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAllNotificationsAsRead = `-- name: MarkAllNotificationsAsRead :execrows
UPDATE notifications
SET is_read = true, read_at = NOW()
WHERE user_id = $1 AND is_read = false
`

func (q *Queries) MarkAllNotificationsAsRead(ctx context.Context, userID pgtype.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, markAllNotificationsAsRead, userID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const markNotificationAsRead = `-- name: MarkNotificationAsRead :one
UPDATE notifications
SET is_read = true, read_at = NOW()
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, title, body, type, campaign_id, scene_id, post_id, is_read, read_at, email_sent_at, created_at, is_urgent, link, expires_at, character_id, metadata
`

type MarkNotificationAsReadParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) MarkNotificationAsRead(ctx context.Context, arg MarkNotificationAsReadParams) (Notification, error) {
	row := q.db.QueryRow(ctx, markNotificationAsRead, arg.ID, arg.UserID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Type,
		&i.CampaignID,
		&i.SceneID,
		&i.PostID,
		&i.IsRead,
		&i.ReadAt,
		&i.EmailSentAt,
		&i.CreatedAt,
		&i.IsUrgent,
		&i.Link,
		&i.ExpiresAt,
		&i.CharacterID,
		&i.Metadata,
	)
	return i, err
}

const markNotificationEmailSent = `-- name: MarkNotificationEmailSent :exec
UPDATE notifications
SET email_sent_at = NOW()
WHERE id = $1
`

func (q *Queries) MarkNotificationEmailSent(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markNotificationEmailSent, id)
	return err
}

const markQueuedNotificationDelivered = `-- name: MarkQueuedNotificationDelivered :exec
UPDATE notification_queue
SET delivered_at = NOW()
WHERE id = $1
`

func (q *Queries) MarkQueuedNotificationDelivered(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markQueuedNotificationDelivered, id)
	return err
}

const queueNotification = `-- name: QueueNotification :one

INSERT INTO notification_queue (
    user_id,
    notification_id,
    deliver_after
) VALUES (
    $1, $2, $3
)
RETURNING id, user_id, notification_id, queued_at, deliver_after, delivered_at
`

type QueueNotificationParams struct {
	UserID         pgtype.UUID        `json:"user_id"`
	NotificationID pgtype.UUID        `json:"notification_id"`
	DeliverAfter   pgtype.Timestamptz `json:"deliver_after"`
}

// ============================================
// NOTIFICATION QUEUE QUERIES
// ============================================
func (q *Queries) QueueNotification(ctx context.Context, arg QueueNotificationParams) (NotificationQueue, error) {
	row := q.db.QueryRow(ctx, queueNotification, arg.UserID, arg.NotificationID, arg.DeliverAfter)
	var i NotificationQueue
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.NotificationID,
		&i.QueuedAt,
		&i.DeliverAfter,
		&i.DeliveredAt,
	)
	return i, err
}

const recordEmailDigest = `-- name: RecordEmailDigest :one

INSERT INTO email_digests (
    user_id,
    digest_type,
    notification_count,
    campaign_ids
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, user_id, digest_type, sent_at, notification_count, campaign_ids
`

type RecordEmailDigestParams struct {
	UserID            pgtype.UUID   `json:"user_id"`
	DigestType        string        `json:"digest_type"`
	NotificationCount int32         `json:"notification_count"`
	CampaignIds       []pgtype.UUID `json:"campaign_ids"`
}

// ============================================
// EMAIL DIGEST QUERIES
// ============================================
func (q *Queries) RecordEmailDigest(ctx context.Context, arg RecordEmailDigestParams) (EmailDigest, error) {
	row := q.db.QueryRow(ctx, recordEmailDigest,
		arg.UserID,
		arg.DigestType,
		arg.NotificationCount,
		arg.CampaignIds,
	)
	var i EmailDigest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DigestType,
		&i.SentAt,
		&i.NotificationCount,
		&i.CampaignIds,
	)
	return i, err
}

const updateQueuedNotificationDeliveryTime = `-- name: UpdateQueuedNotificationDeliveryTime :exec
UPDATE notification_queue
SET deliver_after = $2
WHERE id = $1
`

type UpdateQueuedNotificationDeliveryTimeParams struct {
	ID           pgtype.UUID        `json:"id"`
	DeliverAfter pgtype.Timestamptz `json:"deliver_after"`
}

func (q *Queries) UpdateQueuedNotificationDeliveryTime(ctx context.Context, arg UpdateQueuedNotificationDeliveryTimeParams) error {
	_, err := q.db.Exec(ctx, updateQueuedNotificationDeliveryTime, arg.ID, arg.DeliverAfter)
	return err
}

const upsertNotificationPreferences = `-- name: UpsertNotificationPreferences :one
INSERT INTO notification_preferences (
    user_id,
    email_enabled,
    email_frequency,
    in_app_enabled
) VALUES (
    $1, $2, $3, $4
)
ON CONFLICT (user_id) DO UPDATE SET
    email_enabled = EXCLUDED.email_enabled,
    email_frequency = EXCLUDED.email_frequency,
    in_app_enabled = EXCLUDED.in_app_enabled,
    updated_at = NOW()
RETURNING id, user_id, email_enabled, email_frequency, in_app_enabled, created_at, updated_at
`

type UpsertNotificationPreferencesParams struct {
	UserID         pgtype.UUID           `json:"user_id"`
	EmailEnabled   bool                  `json:"email_enabled"`
	EmailFrequency NotificationFrequency `json:"email_frequency"`
	InAppEnabled   bool                  `json:"in_app_enabled"`
}

func (q *Queries) UpsertNotificationPreferences(ctx context.Context, arg UpsertNotificationPreferencesParams) (NotificationPreference, error) {
	row := q.db.QueryRow(ctx, upsertNotificationPreferences,
		arg.UserID,
		arg.EmailEnabled,
		arg.EmailFrequency,
		arg.InAppEnabled,
	)
	var i NotificationPreference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EmailEnabled,
		&i.EmailFrequency,
		&i.InAppEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertQuietHours = `-- name: UpsertQuietHours :one
INSERT INTO quiet_hours (
    user_id,
    enabled,
    start_time,
    end_time,
    timezone,
    urgent_bypass
) VALUES (
    $1, $2, $3, $4, $5, $6
)
ON CONFLICT (user_id) DO UPDATE SET
    enabled = EXCLUDED.enabled,
    start_time = EXCLUDED.start_time,
    end_time = EXCLUDED.end_time,
    timezone = EXCLUDED.timezone,
    urgent_bypass = EXCLUDED.urgent_bypass,
    updated_at = NOW()
RETURNING id, user_id, enabled, start_time, end_time, timezone, created_at, updated_at, urgent_bypass
`

type UpsertQuietHoursParams struct {
	UserID       pgtype.UUID `json:"user_id"`
	Enabled      bool        `json:"enabled"`
	StartTime    pgtype.Time `json:"start_time"`
	EndTime      pgtype.Time `json:"end_time"`
	Timezone     string      `json:"timezone"`
	UrgentBypass bool        `json:"urgent_bypass"`
}

func (q *Queries) UpsertQuietHours(ctx context.Context, arg UpsertQuietHoursParams) (QuietHour, error) {
	row := q.db.QueryRow(ctx, upsertQuietHours,
		arg.UserID,
		arg.Enabled,
		arg.StartTime,
		arg.EndTime,
		arg.Timezone,
		arg.UrgentBypass,
	)
	var i QuietHour
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Enabled,
		&i.StartTime,
		&i.EndTime,
		&i.Timezone,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UrgentBypass,
	)
	return i, err
}
